<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="因为最近弄自己的博客，涉及到了版本库嵌套的问题。记下来也算是给自己一个备忘。
为什么有这样的需求 版本库嵌套很好理解，就是在一个 Git 仓库里面包含了其他的 Git 仓库。通常有这样的需求往往涉及到协同开发。比如这里有一个插件单独的 Git 仓库姑且叫“Plugin”。现在我创建了一个自己的项目，其中需要用到这个“Plugin”插件。通常比较笨的办法就是把插件库源码拖下来，复制到自己的项目里。但是这样当插件库更新的时候，插件源码更新往往比较麻烦。而且如果在使用的过程中修改了插件的源码，也不便于插件单独的版本控制，更别说为插件库贡献代码了。但如果插件单独以 Git 仓库存在于我的项目目录中，以上的问题就解决了。
在 Git 里面提供了两种方式实现上述需求，那就是 Subtree 和 Submodule。
Submodule Submodule 是 Git 里面最早提供的一种方法。顾名思义“子模块”。
添加子模块 执行
1 $ git submodule add &amp;lt;repo&amp;gt; &amp;lt;module_path&amp;gt; 此时运行 git status 可以看到子模块对应的文件夹和一个叫做 .gitmodules 文件被添加进了暂存区。其中 .gitmodules 是用于记录子模块相关信息的。之后主项目里面的操作照常提交就可以了。
修改子模块 但如果在开发的途中修改了子模块的代码，需要单独到子模块对应的根目录里面进行子模块单独的提交操作。在主项目里面虽然可以看到子模块有变更，但是无法看到具体的更改操作，而是将其看作一个模块整体。一旦子模块产生了新的提交，主项目里面可以看到子模块的 HEAD 变化，从而主项目也应当产生一个新的提交以记录对应关系。 换句话说，主项目就是靠着记录子模块 HEAD 值来判断依赖的。子模块的代码最后将不会进入主项目的版本库里面（只有 HEAD 值）。
现在子模块有了新的提交，为了将服务器上的代码更新，我们只需要进入子模块对应的更目录执行 push 操作就可以了。
更新子模块 此时子模块上游有了新的代码，我们需要将其整合到当前的项目中。有两种方法。
在主项目根目录下运行
1 $ git submodule foreach git pull 或者切换到子模块的根目录下面
1 $ git pull 克隆项目 克隆主项目的时候子模块并不会拉取到本地，如果进入对应的目录会发现是空的。 此时应当
1 $ git submodule init 保持最新"><title>Git 中的 Subtree 和 Submodule</title><link rel=canonical href=https://peromage.github.io/blog/git%E4%B8%AD%E7%9A%84subtree%E5%92%8Csubmodule/><link rel=stylesheet href=/scss/style.min.450926226e724574a6b936335ea06111f8aeb253d932c86cb2cc807341cd2889.css><meta property="og:title" content="Git 中的 Subtree 和 Submodule"><meta property="og:description" content="因为最近弄自己的博客，涉及到了版本库嵌套的问题。记下来也算是给自己一个备忘。
为什么有这样的需求 版本库嵌套很好理解，就是在一个 Git 仓库里面包含了其他的 Git 仓库。通常有这样的需求往往涉及到协同开发。比如这里有一个插件单独的 Git 仓库姑且叫“Plugin”。现在我创建了一个自己的项目，其中需要用到这个“Plugin”插件。通常比较笨的办法就是把插件库源码拖下来，复制到自己的项目里。但是这样当插件库更新的时候，插件源码更新往往比较麻烦。而且如果在使用的过程中修改了插件的源码，也不便于插件单独的版本控制，更别说为插件库贡献代码了。但如果插件单独以 Git 仓库存在于我的项目目录中，以上的问题就解决了。
在 Git 里面提供了两种方式实现上述需求，那就是 Subtree 和 Submodule。
Submodule Submodule 是 Git 里面最早提供的一种方法。顾名思义“子模块”。
添加子模块 执行
1 $ git submodule add &amp;lt;repo&amp;gt; &amp;lt;module_path&amp;gt; 此时运行 git status 可以看到子模块对应的文件夹和一个叫做 .gitmodules 文件被添加进了暂存区。其中 .gitmodules 是用于记录子模块相关信息的。之后主项目里面的操作照常提交就可以了。
修改子模块 但如果在开发的途中修改了子模块的代码，需要单独到子模块对应的根目录里面进行子模块单独的提交操作。在主项目里面虽然可以看到子模块有变更，但是无法看到具体的更改操作，而是将其看作一个模块整体。一旦子模块产生了新的提交，主项目里面可以看到子模块的 HEAD 变化，从而主项目也应当产生一个新的提交以记录对应关系。 换句话说，主项目就是靠着记录子模块 HEAD 值来判断依赖的。子模块的代码最后将不会进入主项目的版本库里面（只有 HEAD 值）。
现在子模块有了新的提交，为了将服务器上的代码更新，我们只需要进入子模块对应的更目录执行 push 操作就可以了。
更新子模块 此时子模块上游有了新的代码，我们需要将其整合到当前的项目中。有两种方法。
在主项目根目录下运行
1 $ git submodule foreach git pull 或者切换到子模块的根目录下面
1 $ git pull 克隆项目 克隆主项目的时候子模块并不会拉取到本地，如果进入对应的目录会发现是空的。 此时应当
1 $ git submodule init 保持最新"><meta property="og:url" content="https://peromage.github.io/blog/git%E4%B8%AD%E7%9A%84subtree%E5%92%8Csubmodule/"><meta property="og:site_name" content="Fang's Blog"><meta property="og:type" content="article"><meta property="article:section" content="Blog"><meta property="article:tag" content="git"><meta property="article:tag" content="中文"><meta property="article:published_time" content="2017-04-07T00:00:00+00:00"><meta property="article:modified_time" content="2022-06-05T21:01:02+00:00"><meta name=twitter:title content="Git 中的 Subtree 和 Submodule"><meta name=twitter:description content="因为最近弄自己的博客，涉及到了版本库嵌套的问题。记下来也算是给自己一个备忘。
为什么有这样的需求 版本库嵌套很好理解，就是在一个 Git 仓库里面包含了其他的 Git 仓库。通常有这样的需求往往涉及到协同开发。比如这里有一个插件单独的 Git 仓库姑且叫“Plugin”。现在我创建了一个自己的项目，其中需要用到这个“Plugin”插件。通常比较笨的办法就是把插件库源码拖下来，复制到自己的项目里。但是这样当插件库更新的时候，插件源码更新往往比较麻烦。而且如果在使用的过程中修改了插件的源码，也不便于插件单独的版本控制，更别说为插件库贡献代码了。但如果插件单独以 Git 仓库存在于我的项目目录中，以上的问题就解决了。
在 Git 里面提供了两种方式实现上述需求，那就是 Subtree 和 Submodule。
Submodule Submodule 是 Git 里面最早提供的一种方法。顾名思义“子模块”。
添加子模块 执行
1 $ git submodule add &amp;lt;repo&amp;gt; &amp;lt;module_path&amp;gt; 此时运行 git status 可以看到子模块对应的文件夹和一个叫做 .gitmodules 文件被添加进了暂存区。其中 .gitmodules 是用于记录子模块相关信息的。之后主项目里面的操作照常提交就可以了。
修改子模块 但如果在开发的途中修改了子模块的代码，需要单独到子模块对应的根目录里面进行子模块单独的提交操作。在主项目里面虽然可以看到子模块有变更，但是无法看到具体的更改操作，而是将其看作一个模块整体。一旦子模块产生了新的提交，主项目里面可以看到子模块的 HEAD 变化，从而主项目也应当产生一个新的提交以记录对应关系。 换句话说，主项目就是靠着记录子模块 HEAD 值来判断依赖的。子模块的代码最后将不会进入主项目的版本库里面（只有 HEAD 值）。
现在子模块有了新的提交，为了将服务器上的代码更新，我们只需要进入子模块对应的更目录执行 push 操作就可以了。
更新子模块 此时子模块上游有了新的代码，我们需要将其整合到当前的项目中。有两种方法。
在主项目根目录下运行
1 $ git submodule foreach git pull 或者切换到子模块的根目录下面
1 $ git pull 克隆项目 克隆主项目的时候子模块并不会拉取到本地，如果进入对应的目录会发现是空的。 此时应当
1 $ git submodule init 保持最新"></head><body class=article-page><script>(function(){const e='StackColorScheme';localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t='StackColorScheme',e=localStorage.getItem(t),n=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;e=='dark'||e==='auto'&&n?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=https://github.com/peromage.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Fang's Blog</a></h1><h2 class=site-description>May the sapphire star lights your way✨</h2></div></header><ol class=social-menu><li><a href=https://github.com/peromage target=_blank title=GitHub><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/archives><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/about><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About</span></a></li><li><a href=/search><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/tech/>tech</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/blog/git%E4%B8%AD%E7%9A%84subtree%E5%92%8Csubmodule/>Git 中的 Subtree 和 Submodule</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Apr 07, 2017</time></div></footer></div></header><section class=article-content><p>因为最近弄自己的博客，涉及到了版本库嵌套的问题。记下来也算是给自己一个备忘。</p><h2 id=为什么有这样的需求>为什么有这样的需求</h2><p>版本库嵌套很好理解，就是在一个 Git 仓库里面包含了其他的 Git 仓库。通常有这样的需求往往涉及到协同开发。比如这里有一个插件单独的 Git 仓库姑且叫“Plugin”。现在我创建了一个自己的项目，其中需要用到这个“Plugin”插件。通常比较笨的办法就是把插件库源码拖下来，复制到自己的项目里。但是这样当插件库更新的时候，插件源码更新往往比较麻烦。而且如果在使用的过程中修改了插件的源码，也不便于插件单独的版本控制，更别说为插件库贡献代码了。但如果插件单独以 Git 仓库存在于我的项目目录中，以上的问题就解决了。</p><p>在 Git 里面提供了两种方式实现上述需求，那就是 Subtree 和 Submodule。</p><h2 id=submodule>Submodule</h2><p>Submodule 是 Git 里面最早提供的一种方法。顾名思义“子模块”。</p><h3 id=添加子模块>添加子模块</h3><p>执行</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git submodule add &lt;repo&gt; &lt;module_path&gt;
</span></span></code></pre></td></tr></table></div></div><p>此时运行 <code>git status</code> 可以看到子模块对应的文件夹和一个叫做 <code>.gitmodules</code> 文件被添加进了暂存区。其中 <code>.gitmodules</code> 是用于记录子模块相关信息的。之后主项目里面的操作照常提交就可以了。</p><h3 id=修改子模块>修改子模块</h3><p>但如果在开发的途中修改了子模块的代码，需要单独到子模块对应的根目录里面进行子模块单独的提交操作。在主项目里面虽然可以看到子模块有变更，但是无法看到具体的更改操作，而是将其看作一个模块整体。一旦子模块产生了新的提交，主项目里面可以看到子模块的 HEAD 变化，从而主项目也应当产生一个新的提交以记录对应关系。
换句话说，主项目就是靠着记录子模块 HEAD 值来判断依赖的。子模块的代码最后将不会进入主项目的版本库里面（只有 HEAD 值）。</p><p>现在子模块有了新的提交，为了将服务器上的代码更新，我们只需要进入子模块对应的更目录执行 push 操作就可以了。</p><h3 id=更新子模块>更新子模块</h3><p>此时子模块上游有了新的代码，我们需要将其整合到当前的项目中。有两种方法。</p><p>在主项目根目录下运行</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git submodule foreach git pull
</span></span></code></pre></td></tr></table></div></div><p>或者切换到子模块的根目录下面</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git pull
</span></span></code></pre></td></tr></table></div></div><h3 id=克隆项目>克隆项目</h3><p>克隆主项目的时候子模块并不会拉取到本地，如果进入对应的目录会发现是空的。
此时应当</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git submodule init
</span></span></code></pre></td></tr></table></div></div><p>保持最新</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git submodule update
</span></span></code></pre></td></tr></table></div></div><p>或者可以直接一条命令搞定</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git clone --recursive &lt;repo&gt;
</span></span></code></pre></td></tr></table></div></div><h3 id=删除子模块>删除子模块</h3><p>Git 中没有提供直接删除的命令，需要手动完成删除操作。</p><p>反向初始化子模块</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git submodule deinit --force &lt;module_path&gt;
</span></span></code></pre></td></tr></table></div></div><p>或者直接删掉 <code>.git/config</code> 里相关信息</p><p>移除子模块</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git rm &lt;module_path&gt;
</span></span></code></pre></td></tr></table></div></div><p>如果暂存区还有</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git rm --cached &lt;module_path&gt;
</span></span></code></pre></td></tr></table></div></div><h3 id=子模块的坑>子模块的坑</h3><h4 id=提交的坑>提交的坑</h4><p>假设有 A B 两个人同时在开发一个项目，这个项目里面也包含了一个子模块。此时 A 修改了业务代码，同时修改了一个子模块里面的一个 bug 。A 将这次修改提交，主项目的提交里面指向了子模块新的 HEAD1 ，然后把主项目的版本库 push 到了服务器，但是没有 push 子模块。B 此时 pull 了主项目，然后 update 子模块，被告知找不到子模块的 HEAD1 。因为指向 HEAD1 的提交还在 A 本地机器上。
这就是子模块提交的坑。在多个模块存在的时候操作非常繁琐。</p><h4 id=初始化的坑>初始化的坑</h4><p>在执行 <code>git submodule init</code> ， <code>git submodule update</code> 之后，此时修改子模块可能出现 HEAD 处于游离状态的的提示。如果不注意极有可能出现丢失提交的可能。
解决办法，在以上两条命令之后执行一次检出</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git checkout &lt;branch&gt;
</span></span></code></pre></td></tr></table></div></div><h2 id=subtree>Subtree</h2><h3 id=添加子项目>添加子项目</h3><p>首先添加子项目对应的远程服务器</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git remote add &lt;subrepo_name&gt; &lt;subrepo_remote&gt;
</span></span></code></pre></td></tr></table></div></div><p>拉取一下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git fetch &lt;subrepo_name&gt;
</span></span></code></pre></td></tr></table></div></div><p>添加子项目到父项目里面</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git subtree add --squash --prefix<span class=o>=</span>&lt;subrepo_path&gt; &lt;subrepo_name&gt; &lt;branch&gt;
</span></span></code></pre></td></tr></table></div></div><p>参数 <code>--squash</code> 作用在于合并子项目所有提交为一个，并 merge 到父项目的历史中，这样只会出现两个提交记录，避免子项目的提交历史污染父项目。更多讨论可以看<a class=link href=http://www.fwolf.com/blog/post/246 target=_blank rel=noopener>这里</a>。</p><h3 id=修改子项目>修改子项目</h3><p>添加完毕之后照常修改提交各种操作，父项目能够跟踪子项目里面的所有变更。子项目被当做一个正常的子文件夹处理。</p><p>如果现在修改了子项目里的一个 bug 并且想要反馈给上游，可以这样操作</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git subtree push --prefix<span class=o>=</span>&lt;subrepo_path&gt; &lt;subrepo_name&gt; &lt;bug_fixed&gt;
</span></span></code></pre></td></tr></table></div></div><p>这个操作可以将父项目里所有涉及子项目修改的提交检出。这样在远程仓库里面会出现一个叫做 <em>bug_fixed</em> 的分支。</p><p>或者也可以这样操作</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git subtree split --prefix<span class=o>=</span>&lt;subrepo_path&gt; --branch &lt;new_branch_name&gt;
</span></span></code></pre></td></tr></table></div></div><p>这个操作跟上面一样将父项目里所有涉及子项目修改的提交检出，并且把子项目的根文件夹设为整个项目的根文件夹，然后检出为父项目的一个新的分支。</p><p>然后推送给上游</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git push &lt;subrepo_remote&gt; &lt;new_branch_name&gt;:&lt;bug_fixed&gt;
</span></span></code></pre></td></tr></table></div></div><p>之后删除对应本地分支就可以了。</p><h3 id=更新子项目>更新子项目</h3><p>拉取非常方便</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git subtree pull --prefix<span class=o>=</span>&lt;subrepo_path&gt; &lt;subrepo_name&gt; &lt;branch&gt;
</span></span></code></pre></td></tr></table></div></div><h3 id=删除子项目>删除子项目</h3><p>因为子项目在父项目里面就是被当做一个普通的文件夹处理的，所以直接移除文件夹并提交就可以了。</p><h2 id=submodule-vs-dot-subtree>Submodule vs. Subtree</h2><p>Git 官方推荐使用新的 Subtree ，事实证明的确比 Submodule 方便不少。Subtree 不会产生额外的文件，而且子项目的代码包含在父项目里面，不会出现前面提到的坑的问题。具体应用上的对比可以参考<a class=link href=https://gist.github.com/kvnsmth/4688345 target=_blank rel=noopener>这篇文章</a>。Subtree 对于代码迭代较快的项目尤为适合。</p><p>但也不是说 Submodule 一无是处， Submodule 在我感觉最大的意义在于可以隔离子项目的业务代码，并且记录严格的依赖关系。对于一些子模块更新较慢的项目还是比较适合的。</p><h2 id=参考>参考</h2><p><a class=link href=https://gist.github.com/kvnsmth/4688345 target=_blank rel=noopener>subtree_usage</a>
<a class=link href=http://www.fwolf.com/blog/post/246 target=_blank rel=noopener>subtree_squash</a></p></section><footer class=article-footer><section class=article-tags><a href=/tags/git/>git</a>
<a href=/tags/%E4%B8%AD%E6%96%87/>中文</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC 4.0</span></section><section class=article-lastmod><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>Last updated on Jun 05, 2022 21:01 UTC</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>Related contents</h2><div class=related-contents><div class="flex article-list--tile"><article><a href=/blog/windows-linux%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E6%89%8B%E8%AE%B0/><div class=article-details><h2 class=article-title>Windows + Linux 双系统引导手记</h2></div></a></article><article><a href=/blog/fix-metadata-in-google-photo-takeout/><div class=article-details><h2 class=article-title>Fix Metadata in Google Photo Takeout</h2></div></a></article><article><a href=/blog/ssh-over-gpg-agent/><div class=article-details><h2 class=article-title>SSH Over GPG Agent</h2></div></a></article><article><a href=/blog/setup-a-gaming-vm/><div class=article-details><h2 class=article-title>Setup A Gaming VM</h2></div></a></article><article><a href=/blog/shadowsocks-quick-setup/><div class=article-details><h2 class=article-title>Shadowsocks Quick Setup</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2017 -
2022 Fang's Blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.11.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#为什么有这样的需求>为什么有这样的需求</a></li><li><a href=#submodule>Submodule</a><ol><li><a href=#添加子模块>添加子模块</a></li><li><a href=#修改子模块>修改子模块</a></li><li><a href=#更新子模块>更新子模块</a></li><li><a href=#克隆项目>克隆项目</a></li><li><a href=#删除子模块>删除子模块</a></li><li><a href=#子模块的坑>子模块的坑</a><ol><li><a href=#提交的坑>提交的坑</a></li><li><a href=#初始化的坑>初始化的坑</a></li></ol></li></ol></li><li><a href=#subtree>Subtree</a><ol><li><a href=#添加子项目>添加子项目</a></li><li><a href=#修改子项目>修改子项目</a></li><li><a href=#更新子项目>更新子项目</a></li><li><a href=#删除子项目>删除子项目</a></li></ol></li><li><a href=#submodule-vs-dot-subtree>Submodule vs. Subtree</a></li><li><a href=#参考>参考</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement('link');e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>