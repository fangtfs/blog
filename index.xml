<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Peromage&#39;s Blog</title>
        <link>https://peromage.github.io/</link>
        <description>Recent content on Peromage&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Sun, 18 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://peromage.github.io/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Dual-booting Windows VHD and Native Linux on a BIOS&#43;GPT PC</title>
        <link>https://peromage.github.io/p/dual-booting-windows-vhd-and-native-linux-on-a-bios-gpt-pc/</link>
        <pubDate>Fri, 09 Jul 2021 16:40:31 +0000</pubDate>
        
        <guid>https://peromage.github.io/p/dual-booting-windows-vhd-and-native-linux-on-a-bios-gpt-pc/</guid>
        <description>&lt;h1 id=&#34;background&#34;&gt;Background&lt;/h1&gt;
&lt;p&gt;Previously I wrote a post for this dual-boot scenario. It is a little outdated. In the past year I mostly worked in the Linux environment on my old laptop, so the Windows seems not to be a necessity which occupies a dedicated partition. However, sometimes it is still needed. That is why I started thinking to improve this setup even further.&lt;/p&gt;
&lt;p&gt;Starting from Windows 7, Windows supports boots from a VHD file which makes it so much easier to manage. Also you are able to create differencing disks which are pretty much like snapshots.&lt;/p&gt;
&lt;p&gt;For this new configuration, my plan is to use &lt;em&gt;BIOS + GPT disk table + Native Linux + Native Windows booting from VHD + GRUB as the bootloader&lt;/em&gt;.&lt;/p&gt;
&lt;h1 id=&#34;partitioning&#34;&gt;Partitioning&lt;/h1&gt;
&lt;p&gt;To make GPT works with BIOS. It is required to have a small partition &lt;a class=&#34;link&#34; href=&#34;https://wiki.archlinux.org/title/GRUB&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;flagged&lt;/a&gt; with &lt;code&gt;EF02&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The partition scheme looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Device         Start        End   Sectors   Size Type
/dev/sda1         34       2047      2014  1007K BIOS boot
/dev/sda2       2048    1026047   1024000   500M EFI System
/dev/sda3    1026048  206546943 205520896    98G Linux filesystem
/dev/sda4  206546944  835692543 629145600   300G Linux filesystem
/dev/sda5  835692544 1465149134 629456591 300.1G Microsoft basic data
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;installing-linux&#34;&gt;Installing Linux&lt;/h1&gt;
&lt;p&gt;Any Linux distro would work. I chose Manjaro KDE this time because I found that the Pop OS made my laptop really hot sometimes (Yeah KDE is prettier).&lt;/p&gt;
&lt;p&gt;This part should be easy. The GRUB files is going into that EFI partition. For details, check &lt;a class=&#34;link&#34; href=&#34;https://wiki.archlinux.org/title/GRUB&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GRUB wiki&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&#34;preparing-to-install-windows&#34;&gt;Preparing to Install Windows&lt;/h1&gt;
&lt;p&gt;I&amp;rsquo;m not going to use the standard Windwos installer since I want to install it into a VHD file. To make it work we need a Windows PE environment.&lt;/p&gt;
&lt;h2 id=&#34;preparing-images&#34;&gt;Preparing Images&lt;/h2&gt;
&lt;p&gt;Any Windows PE (Windows 7 and above) would work. The PE ISO image is going to &lt;code&gt;/boot/wepe.iso&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Also a Windows ISO image is needed. For example a Windows 7 ISO named &lt;code&gt;windows7.iso&lt;/code&gt; will be put in the Windows data partition.&lt;/p&gt;
&lt;h2 id=&#34;adding-windows-pe-to-grub&#34;&gt;Adding Windows PE to GRUB&lt;/h2&gt;
&lt;p&gt;Boot into Linux. Download Windows PE ISO file and move it to the EFI partition (EXT4 partitions might be problematic).&lt;/p&gt;
&lt;p&gt;To load this ISO image, &lt;code&gt;memdisk&lt;/code&gt; tool from &lt;code&gt;syslinux&lt;/code&gt; is required. Steps as below on Arch based distro:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Installing syslinux&lt;/span&gt;
$ sudo pacman -S syslinux

&lt;span class=&#34;c1&#34;&gt;# Copying `memdisk` to the boot partition&lt;/span&gt;
$ sudo cp /usr/lib/syslinux/bios/memdisk /boot/memdisk

&lt;span class=&#34;c1&#34;&gt;# Adding Windows PE entry to GRUB. 1DB1-9C31 is the boot partition&amp;#39;s UUID&lt;/span&gt;
$ sudo cat &lt;span class=&#34;s&#34;&gt;&amp;lt;&amp;lt;EOF &amp;gt;&amp;gt;/etc/grub.d/40_custom
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;menuentry &amp;#34;WePE x64&amp;#34; {
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;    search --set=root --no-floppy --fs-uuid 1DB1-9C31
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;    linux16 /memdisk iso ro
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;    initrd16 /wepe.iso
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;}
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;EOF&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# Updating GRUB entries&lt;/span&gt;
$ sudo grub-mkconfig -o /boot/grub/grub.cfg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;installing-windows-to-a-vhd-file&#34;&gt;Installing Windows to a VHD File&lt;/h1&gt;
&lt;p&gt;After adding Windows PE to the bootloader entries, it is time to switch the working environment.&lt;/p&gt;
&lt;p&gt;Restart the PC, then keep pression &lt;code&gt;shift&lt;/code&gt; key until the GRUB menu shows up. Now navigate to the Windows PE entry and get in there.&lt;/p&gt;
&lt;h2 id=&#34;creating-a-vhd-file-for-windows&#34;&gt;Creating a VHD File for Windows&lt;/h2&gt;
&lt;p&gt;To create a VHD file, open a command line window and enter &lt;code&gt;diskpart&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;# Create a VHD file assuming the NTFS data partition is assigned with D:
DISKPART&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; create vdisk file=d:\windows7.vhd maximum=64000 type=fixed
DISKPART&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; select vdisk file=d:\windows7.vhd
DISKPART&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; attach vdisk

# Disk table type doesn&amp;#39;t matter but using MBR for better compatibility
DISKPART&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; convert mbr

# Create the system partition and assign it with C:
DISKPART&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; create partition primary
DISKPART&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; format fs=ntfs quick
DISKPART&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; assign letter=c
DISKPART&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; exit 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now the Windows image can be dumped into this VHD file.&lt;/p&gt;
&lt;h2 id=&#34;extracting-windows-image&#34;&gt;Extracting Windows Image&lt;/h2&gt;
&lt;p&gt;Mount the Windows ISO image to &lt;code&gt;E:&lt;/code&gt; volume and open a command line window&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;# Get the image index. For example the desired version&amp;#39;s index is 1
&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; dism /get-wiminfo /wimfile=e:\sources\install.wim

# Extract the image. Where E: is the Windows ISO and C: is the VHD file
&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; dism /apply-image /imagefile:e:\sources\install.wim /index:1 /applydir:c:\
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;fixing-the-windows-bootloader&#34;&gt;Fixing the Windows Bootloader&lt;/h1&gt;
&lt;p&gt;Stay in Windows PE. Don&amp;rsquo;t restart the PC. We still need to fix the bootloader for Windows.&lt;/p&gt;
&lt;p&gt;Normally Windows cannot be booted with a GPT+MBR setup. And also loading the whole Windows VHD file through &lt;code&gt;memdisk&lt;/code&gt; is not possible because it&amp;rsquo;s too large to load into memory. To fix the boot issue a bridge is needed between Windows and GRUB.&lt;/p&gt;
&lt;p&gt;Luckily &lt;a class=&#34;link&#34; href=&#34;http://reboot.pro/index.php?showtopic=19516&amp;amp;page=2&amp;amp;#entry184489&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;a small VHD image&lt;/a&gt; can still be loaded by &lt;code&gt;memdisk&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The idea is: GRUB -&amp;gt; MS Bootmgr VHD -&amp;gt; Windows VHD&lt;/p&gt;
&lt;h2 id=&#34;creating-a-dedicated-bootloader-image-for-windows&#34;&gt;Creating a Dedicated Bootloader Image for Windows&lt;/h2&gt;
&lt;p&gt;It is same with the process creating a VHD file for Windows system but this time it is a smaller file (32 MB).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;# Create a small bootmgr VHD file in the data partition
DISKPART&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; create vdisk file=d:\bootmgr.vhd maximum=32 type=fixed
DISKPART&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; select vdisk file=d:\bootmgr.vhd
DISKPART&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; attach vdisk
DISKPART&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; convert mbr
DISKPART&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; create partition primary
DISKPART&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; format fs=ntfs quick
DISKPART&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; assign letter=f
DISKPART&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; exit 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now the &lt;code&gt;bootmgr&lt;/code&gt; VHD is mounted at F:. Then write the boot record and create boot configuration files.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; bootsect /nt60 f: /mbr
&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; bcdboot c:\Windows /l en-us /s f: /f bios
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;fixing-the-bcd-entry&#34;&gt;Fixing the BCD Entry&lt;/h2&gt;
&lt;p&gt;At this point it should be working according to the &lt;a class=&#34;link&#34; href=&#34;https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/boot-to-vhd--native-boot--add-a-virtual-hard-disk-to-the-boot-menu&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Microsoft&amp;rsquo;s document&lt;/a&gt;. In fact it is not.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s check the BCD entries, in a command window:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; bcdedit /store f:\Boot\BCD /enum

Windows Boot Manager
--------------------
identifier              {bootmgr}
device                  partition=F:
description             Windows Boot Manager
locale                  en-us
inherit                 {globalsettings}
default                 {default}
resumeobject            {fcd67427-e033-11eb-8826-cdf90e3873d0}
displayorder            {default}
toolsdisplayorder       {memdiag}
timeout                 30

Windows Boot Loader
-------------------
identifier              {default}
device                  partition=C:
&lt;span class=&#34;k&#34;&gt;path&lt;/span&gt;                    \Windows\system32\winload.exe
description             Windows 7
locale                  en-us
inherit                 {bootloadersettings}
osdevice                partition=C:
systemroot              \Windows
resumeobject            {fcd67427-e033-11eb-8826-cdf90e3873d0}
nx                      OptIn
detecthal               Yes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;device&lt;/code&gt; and &lt;code&gt;osdevice&lt;/code&gt; seems to be right but once the Windows VHD is unmounted it becomes &lt;code&gt;unknown&lt;/code&gt;. According to this &lt;a class=&#34;link&#34; href=&#34;http://www.mistyprojects.co.uk/documents/BCDEdit/files/device.htm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;BCDEdit notes&lt;/a&gt;, BCD entry records the partition&amp;rsquo;s information such as UUID to find the correct partition during bootup. In this case the partition can&amp;rsquo;t be found until the VHD file is mounted. But this VHD file is not mounted automatically.&lt;/p&gt;
&lt;p&gt;Thus we need to correct this and let &lt;code&gt;Bootmgr&lt;/code&gt; locate the VHD file properly.&lt;/p&gt;
&lt;p&gt;In a command line window:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;# The identifier must match the one which is showing above
&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; bcdedit /store C:\Boot\BCD /set {default} device vhd=[D:]\windows7.vhd
&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; bcdedit /store C:\Boot\BCD /set {default} osdevice vhd=[D:]\windows7.vhd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If we check the BCD entry again it doesn&amp;rsquo;t change. But if we unmount the Windows VHD it will become:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; bcdedit /store f:\Boot\BCD /enum

Windows Boot Manager
--------------------
identifier              {bootmgr}
device                  partition=E:
description             Windows Boot Manager
locale                  en-us
inherit                 {globalsettings}
default                 {default}
resumeobject            {fcd67427-e033-11eb-8826-cdf90e3873d0}
displayorder            {default}
toolsdisplayorder       {memdiag}
timeout                 30

Windows Boot Loader
-------------------
identifier              {default}
device                  vhd=[C:]\windows7.vhd
path                    \Windows\system32\winload.exe
description             Windows 7
locale                  en-us
inherit                 {bootloadersettings}
osdevice                vhd=[C:]\windows7.vhd
systemroot              \Windows
resumeobject            {fcd67427-e033-11eb-8826-cdf90e3873d0}
nx                      OptIn
detecthal               Yes
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The volume letter doesn&amp;rsquo;t matter, it changes dynamically. Now &lt;code&gt;bootmgr&lt;/code&gt; is able to locate the VHD file correctly.&lt;/p&gt;
&lt;h1 id=&#34;adding-windows-to-grub&#34;&gt;Adding Windows to GRUB&lt;/h1&gt;
&lt;p&gt;Restart PC and get into Linux.&lt;/p&gt;
&lt;p&gt;Modify the GRUB config file to load &lt;code&gt;bootmgr&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Adding Windows (bootmgr) entry to GRUB. 1DB1-9C31 is the boot partition&amp;#39;s UUID&lt;/span&gt;
$ sudo cat &lt;span class=&#34;s&#34;&gt;&amp;lt;&amp;lt;EOF &amp;gt;&amp;gt;/etc/grub.d/40_custom
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;menuentry &amp;#34;Windows 7&amp;#34; {
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;    search --set=root --no-floppy --fs-uuid 1DB1-9C31
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;    linux16 /memdisk harddisk
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;    initrd16 /bootmgr.vhd
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;}
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;EOF&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# Updating GRUB entries&lt;/span&gt;
$ sudo grub-mkconfig -o /boot/grub/grub.cfg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now we can restart PC. Keep pressing &lt;code&gt;shift&lt;/code&gt; on bootup to go to the GRUB menu. Select Windows entry to boot Windows.&lt;/p&gt;
&lt;h1 id=&#34;fixing-windows-initialization-error&#34;&gt;Fixing Windows Initialization Error&lt;/h1&gt;
&lt;p&gt;During the first time bootup, Windows might have an error showing &lt;em&gt;Windows could not complete the installation. To install Windows on this computer, restart the installation&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;To &lt;a class=&#34;link&#34; href=&#34;https://www.howisolve.com/windows-could-not-complete-the-installation-solved/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;solve&lt;/a&gt; this error:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Press &lt;code&gt;SHIFT + F10&lt;/code&gt; to bring up the command prompt.&lt;/li&gt;
&lt;li&gt;Execute &lt;code&gt;C:\windows\system32\oobe\msoobe&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Wait for a while and the setup window will show up.&lt;/li&gt;
&lt;li&gt;Complete the setup and restart.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;creating-a-differencing-disk&#34;&gt;Creating a Differencing Disk&lt;/h1&gt;
&lt;p&gt;A differencing disk can be used for quick recoveries.&lt;/p&gt;
&lt;p&gt;To create it, restart into the Windows PE environment. In a command line window:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;# Use the original VHD as base
&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; move d:\windows7.vhd d:\windows7_base.vhd

# Create a differencing disk based on the original one
# The name of the new differencing disk has to be the name that was recorded in the BCD
&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; diskpart
DISKPART&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; creat vdisk file=d:\windows7.vhd parent=d:\windows7_base.vhd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then all changes made in the future will go into the differencing disk. If system goes wrong one day, simply deleting the the differencing disk and creating a new one would quickly recover from the crysis.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTE: After creating the differencing disk, the base VHD is not supposed to be modified.&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://wiki.archlinux.org/title/GRUB&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GRUB wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://wzyboy.im/post/1049.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;BIOS + GPT + GRUB + Linux + Windows 折腾笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://rimo.site/2017/02/08/install-win7-into-vhd/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;在 VHD 中安装 Windows 7&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://reboot.pro/index.php?showtopic=19516&amp;amp;page=2&amp;amp;#entry184489&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Hack Bootmgr to boot Windows in BIOS to GPT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/boot-to-vhd--native-boot--add-a-virtual-hard-disk-to-the-boot-menu&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Boot to a virtual hard disk: Add a VHDX or VHD to the boot menu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.mistyprojects.co.uk/documents/BCDEdit/files/device.htm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;BCDEdit notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.howisolve.com/windows-could-not-complete-the-installation-solved/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;100% Solved:Windows could not complete the installation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Git 中的 Subtree 和 Submodule</title>
        <link>https://peromage.github.io/p/git-%E4%B8%AD%E7%9A%84-subtree-%E5%92%8C-submodule/</link>
        <pubDate>Fri, 07 Apr 2017 20:53:53 +0000</pubDate>
        
        <guid>https://peromage.github.io/p/git-%E4%B8%AD%E7%9A%84-subtree-%E5%92%8C-submodule/</guid>
        <description>&lt;p&gt;因为最近弄自己的博客，涉及到了版本库嵌套的问题。记下来也算是给自己一个备忘。&lt;/p&gt;
&lt;h1 id=&#34;为什么有这样的需求&#34;&gt;为什么有这样的需求&lt;/h1&gt;
&lt;p&gt;版本库嵌套很好理解，就是在一个 Git 仓库里面包含了其他的 Git 仓库。通常有这样的需求往往涉及到协同开发。比如这里有一个插件单独的 Git 仓库姑且叫“Plugin”。现在我创建了一个自己的项目，其中需要用到这个“Plugin”插件。通常比较笨的办法就是把插件库源码拖下来，复制到自己的项目里。但是这样当插件库更新的时候，插件源码更新往往比较麻烦。而且如果在使用的过程中修改了插件的源码，也不便于插件单独的版本控制，更别说为插件库贡献代码了。但如果插件单独以 Git 仓库存在于我的项目目录中，以上的问题就解决了。&lt;/p&gt;
&lt;p&gt;在 Git 里面提供了两种方式实现上述需求，那就是 Subtree 和 Submodule。&lt;/p&gt;
&lt;h1 id=&#34;submodule&#34;&gt;Submodule&lt;/h1&gt;
&lt;p&gt;Submodule 是 Git 里面最早提供的一种方法。顾名思义“子模块”。&lt;/p&gt;
&lt;h2 id=&#34;添加子模块&#34;&gt;添加子模块&lt;/h2&gt;
&lt;p&gt;执行&lt;br&gt;
&lt;code&gt;git submodule add &amp;lt;repo&amp;gt; &amp;lt;module_path&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此时运行 &lt;code&gt;git status&lt;/code&gt; 可以看到子模块对应的文件夹和一个叫做 &lt;em&gt;.gitmodules&lt;/em&gt; 文件被添加进了暂存区。其中*.gitmodules*是用于记录子模块相关信息的。之后主项目里面的操作照常提交就可以了。&lt;/p&gt;
&lt;h2 id=&#34;修改子模块&#34;&gt;修改子模块&lt;/h2&gt;
&lt;p&gt;但如果在开发的途中修改了子模块的代码，需要单独到子模块对应的根目录里面进行子模块单独的提交操作。在主项目里面虽然可以看到子模块有变更，但是无法看到具体的更改操作，而是将其看作一个模块整体。一旦子模块产生了新的提交，主项目里面可以看到子模块的 HEAD 变化，从而主项目也应当产生一个新的提交以记录对应关系。&lt;br&gt;
换句话说，主项目就是靠着记录子模块 HEAD 值来判断依赖的。&lt;strong&gt;子模块的代码最后将不会进入主项目的版本库里面（只有 HEAD 值）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在子模块有了新的提交，为了将服务器上的代码更新，我们只需要进入子模块对应的更目录执行 push 操作就可以了。&lt;/p&gt;
&lt;h2 id=&#34;更新子模块&#34;&gt;更新子模块&lt;/h2&gt;
&lt;p&gt;此时子模块上游有了新的代码，我们需要将其整合到当前的项目中。有两种方法。&lt;/p&gt;
&lt;p&gt;在主项目根目录下运行&lt;br&gt;
&lt;code&gt;git submodule foreach git pull&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或者切换到子模块的根目录下面
&lt;code&gt;git pull&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;克隆项目&#34;&gt;克隆项目&lt;/h2&gt;
&lt;p&gt;克隆主项目的时候子模块并不会拉取到本地，如果进入对应的目录会发现是空的。&lt;br&gt;
此时应当&lt;br&gt;
&lt;code&gt;git submodule init&lt;/code&gt;&lt;br&gt;
保持最新&lt;br&gt;
&lt;code&gt;git submodule update&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或者可以直接一条命令搞定&lt;br&gt;
&lt;code&gt;git clone --recursive &amp;lt;repo&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;删除子模块&#34;&gt;删除子模块&lt;/h2&gt;
&lt;p&gt;Git 中没有提供直接删除的命令，需要手动完成删除操作。&lt;/p&gt;
&lt;p&gt;反向初始化子模块&lt;br&gt;
&lt;code&gt;git submodule deinit --force &amp;lt;module_path&amp;gt;&lt;/code&gt;&lt;br&gt;
或者直接删掉 &lt;em&gt;.git/config&lt;/em&gt; 里相关信息&lt;/p&gt;
&lt;p&gt;移除子模块&lt;br&gt;
&lt;code&gt;git rm &amp;lt;module_path&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果暂存区还有
&lt;code&gt;git rm --cached &amp;lt;module_path&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;子模块的坑&#34;&gt;子模块的坑&lt;/h2&gt;
&lt;h3 id=&#34;提交的坑&#34;&gt;提交的坑&lt;/h3&gt;
&lt;p&gt;假设有 A B 两个人同时在开发一个项目，这个项目里面也包含了一个子模块。此时 A 修改了业务代码，同时修改了一个子模块里面的一个 bug 。A 将这次修改提交，主项目的提交里面指向了子模块新的 HEAD1 ，然后把主项目的版本库 push 到了服务器，但是没有 push 子模块。B 此时 pull 了主项目，然后 update 子模块，被告知找不到子模块的 HEAD1 。因为指向 HEAD1 的提交还在 A 本地机器上。&lt;br&gt;
这就是子模块提交的坑。在多个模块存在的时候操作非常繁琐。&lt;/p&gt;
&lt;h3 id=&#34;初始化的坑&#34;&gt;初始化的坑&lt;/h3&gt;
&lt;p&gt;在执行 &lt;code&gt;git submodule init&lt;/code&gt;， &lt;code&gt;git submodule update&lt;/code&gt; 之后，此时修改子模块可能出现 HEAD 处于游离状态的的提示。如果不注意极有可能出现丢失提交的可能。&lt;br&gt;
解决办法，在以上两条命令之后执行一次检出&lt;br&gt;
&lt;code&gt;git checkout &amp;lt;branch&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;subtree&#34;&gt;Subtree&lt;/h1&gt;
&lt;h2 id=&#34;添加子项目&#34;&gt;添加子项目&lt;/h2&gt;
&lt;p&gt;首先添加子项目对应的远程服务器&lt;br&gt;
&lt;code&gt;git remote add &amp;lt;subrepo_name&amp;gt; &amp;lt;subrepo_remote&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;拉取一下&lt;br&gt;
&lt;code&gt;git fetch &amp;lt;subrepo_name&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;添加子项目到父项目里面&lt;br&gt;
&lt;code&gt;git subtree add --squash --prefix=&amp;lt;subrepo_path&amp;gt; &amp;lt;subrepo_name&amp;gt; &amp;lt;branch&amp;gt;&lt;/code&gt;&lt;br&gt;
参数 &lt;em&gt;&amp;ndash;squash&lt;/em&gt; 作用在于合并子项目所有提交为一个，并 merge 到父项目的历史中，这样只会出现两个提交记录，避免子项目的提交历史污染父项目。更多讨论可以看&lt;a class=&#34;link&#34; href=&#34;http://www.fwolf.com/blog/post/246&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;strong&gt;这里&lt;/strong&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;修改子项目&#34;&gt;修改子项目&lt;/h2&gt;
&lt;p&gt;添加完毕之后照常修改提交各种操作，父项目能够跟踪子项目里面的所有变更。子项目被当做一个正常的子文件夹处理。&lt;/p&gt;
&lt;p&gt;如果现在修改了子项目里的一个 bug 并且想要反馈给上游，可以这样操作&lt;br&gt;
&lt;code&gt;git subtree push --prefix=&amp;lt;subrepo_path&amp;gt; &amp;lt;subrepo_name&amp;gt; &amp;lt;bug_fixed&amp;gt;&lt;/code&gt;&lt;br&gt;
这个操作可以将父项目里所有涉及子项目修改的提交检出。这样在远程仓库里面会出现一个叫做 &lt;em&gt;bug_fixed&lt;/em&gt; 的分支。&lt;/p&gt;
&lt;p&gt;或者也可以这样操作&lt;br&gt;
&lt;code&gt;git subtree split --prefix=&amp;lt;subrepo_path&amp;gt; --branch &amp;lt;new_branch_name&amp;gt;&lt;/code&gt;&lt;br&gt;
这个操作跟上面一样将父项目里所有涉及子项目修改的提交检出，并且把子项目的根文件夹设为整个项目的根文件夹，然后检出为父项目的一个新的分支。&lt;/p&gt;
&lt;p&gt;然后推送给上游&lt;br&gt;
&lt;code&gt;git push &amp;lt;subrepo_remote&amp;gt; &amp;lt;new_branch_name&amp;gt;:&amp;lt;bug_fixed&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;之后删除对应本地分支就可以了。&lt;/p&gt;
&lt;h2 id=&#34;更新子项目&#34;&gt;更新子项目&lt;/h2&gt;
&lt;p&gt;拉取非常方便&lt;br&gt;
&lt;code&gt;git subtree pull --prefix=&amp;lt;subrepo_path&amp;gt; &amp;lt;subrepo_name&amp;gt; &amp;lt;branch&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;删除子项目&#34;&gt;删除子项目&lt;/h2&gt;
&lt;p&gt;因为子项目在父项目里面就是被当做一个普通的文件夹处理的，所以直接移除文件夹并提交就可以了。&lt;/p&gt;
&lt;h1 id=&#34;submodule-vs-subtree&#34;&gt;Submodule vs. Subtree&lt;/h1&gt;
&lt;p&gt;Git 官方推荐使用新的 Subtree ，事实证明的确比 Submodule 方便不少。Subtree 不会产生额外的文件，而且子项目的代码包含在父项目里面，不会出现前面提到的坑的问题。具体应用上的对比可以参考&lt;a class=&#34;link&#34; href=&#34;https://gist.github.com/kvnsmth/4688345&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;strong&gt;这篇文章&lt;/strong&gt;&lt;/a&gt;。Subtree 对于代码迭代较快的项目尤为适合。&lt;/p&gt;
&lt;p&gt;但也不是说 Submodule 一无是处， Submodule 在我感觉最大的意义在于可以隔离子项目的业务代码，并且记录严格的依赖关系。对于一些子模块更新较慢的项目还是比较适合的。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Windows &#43; Linux 双系统引导手记</title>
        <link>https://peromage.github.io/p/windows-linux-%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E6%89%8B%E8%AE%B0/</link>
        <pubDate>Wed, 05 Apr 2017 19:26:41 +0000</pubDate>
        
        <guid>https://peromage.github.io/p/windows-linux-%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E6%89%8B%E8%AE%B0/</guid>
        <description>&lt;h1 id=&#34;0x00-情况简述&#34;&gt;0x00 情况简述&lt;/h1&gt;
&lt;p&gt;由于开发需要 Linux 环境，所以将老的那台笔记本改造成了双系统。&lt;br&gt;
这台电脑的基本情况是这样的，64GB 固态硬盘 + 720GB 机械硬盘（实际可用空间有折损，这里为了表示方便），Windows 10 已经安装到了固态硬盘上。由于主板较老，只能支持 BIOS。巨硬又说过 Windows 只能支持 BIOS + MBR，所以第一块主位（Master）上的固态硬盘就只能采用 MBR 分区表，分成了两个区，500MB 用作启动分区，剩下的部分全部划给了系统分区。&lt;br&gt;
但是 Linux 表示没有巨硬这种尿性，所以为什么不使用更先进的 GPT 分区表？因此从位（Slave）上的机械硬盘被我分成了这个样子：&lt;br&gt;
&lt;strong&gt;10MB BIOS 启动分区（No File System） + 500MB /boot 启动挂载点（EXT4） + 100GB / 根挂载点（EXT4） +  199.5GB /home 用户目录挂载点（EXT4） + 420GB Windows 数据分区（NTFS）&lt;/strong&gt;。&lt;br&gt;
BIOS 启动分区 1MB 足以，我只是考虑到后续扩展问题。之后在第二块硬盘上安装了 Arch Linux。&lt;/p&gt;
&lt;h1 id=&#34;0x01-有啥好折腾的&#34;&gt;0x01 有啥好折腾的？&lt;/h1&gt;
&lt;p&gt;双系统安装好以后相安无事，BIOS 默认从主位固态硬盘启动。也就是说开机不进行任何操作的话，默认进入的是 Windows 10。只有在开机的时候使用 BIOS 的 Fast Boot 功能，选择从第二块硬盘启动才能进入 Arch Linux。换句话说两个系统彼此都是透明的。
但是作为一个强迫症和完美主义者，万一我想进入 Linux，但是开机的时候错过了，岂不是要重启一次才行？或者万一我又反悔想进入 Windows 又要重启一次？这怎么能忍，所以才有了这次的折腾……&lt;/p&gt;
&lt;h1 id=&#34;0x02-在-grub-中添加引导菜单&#34;&gt;0x02 在 GRUB 中添加引导菜单&lt;/h1&gt;
&lt;p&gt;对于 GRUB （注：这里所说的 GRUB 指的是 GRUB 2 而不是 GRUB Legacy） 引导的 Linux 来说，切换到 Windows 的 &lt;em&gt;bootmgr&lt;/em&gt; 是一件很容易的事情，最新版的 GRUB 可以直接启动 &lt;em&gt;bootmgr&lt;/em&gt; 而不需要之前的 chainloading 模式。
进入 Arch Linux，以 root 权限编辑 &lt;em&gt;&lt;strong&gt;/etc/grub.d/40_custom&lt;/strong&gt;&lt;/em&gt; ，加入以下菜单：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;menuentry &amp;quot;Switch to Microsoft Boot Manager&amp;quot; {
    insmod part_msdos
    insmod ntfs
    insmod search_fs_uuid
    insmod ntldr     
    search --fs-uuid --set=root  69B235F6749E84CE
    ntldr /bootmgr
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;insmod&lt;/code&gt; 是用于加载必要的模块以便 GRUB 识别并正确启动 Windows。值得注意的是，&lt;code&gt;search&lt;/code&gt; 一行指定的 UUID 与 Linux 下 &lt;strong&gt;&lt;code&gt;lsblk -f&lt;/code&gt;&lt;/strong&gt; 看到的 UUID 是不一样的，需要使用 &lt;strong&gt;&lt;code&gt;sudo grub-probe --target=fs_uuid -d /dev/sda1&lt;/code&gt;&lt;/strong&gt; 来获取 GRUB 下对应的分区 UUID。这个例子中，Windows 启动分区是 &lt;em&gt;sda1&lt;/em&gt;。UUID 是唯一的，勿照搬。&lt;/p&gt;
&lt;p&gt;当然也可以使用传统的 chainloading 模式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;menuentry &amp;quot;Switch to Microsoft Boot Manager&amp;quot; {
    insmod part_msdos
    insmod ntfs
    insmod search_fs_uuid  
    search --fs-uuid --set=root  69B235F6749E84CE
    chainloader +1
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;保存以后，执行 &lt;strong&gt;&lt;code&gt;sudo grub-mkconfig -o /boot/grub/grub.cfg&lt;/code&gt;&lt;/strong&gt; ，以便更新启动菜单。&lt;br&gt;
不推荐直接编辑 &lt;em&gt;&lt;strong&gt;/boot/grub/grub.cfg&lt;/strong&gt;&lt;/em&gt;，因为上述命令会覆盖这个文件，不便于自定义菜单的管理。&lt;br&gt;
这样就可以直接跳转到 &lt;em&gt;bootmgr&lt;/em&gt;，让它去启动 Windows。&lt;/p&gt;
&lt;h1 id=&#34;0x03-bcd-寻思&#34;&gt;0x03 BCD 寻思&lt;/h1&gt;
&lt;p&gt;BCD 是Windows Vista 之后使用的一种启动管理器。有个非常蛋疼的问题就在于，BCD 并不支持 EXT4 分区格式，所以没有办法读到 GRUB。查阅了相关资料，给出的解决办法就是，将 &lt;em&gt;&lt;strong&gt;/boot&lt;/strong&gt;&lt;/em&gt; 分区格式化成 FAT32 的文件系统。难道我还得再折腾一次文件系统？直觉告诉我一定还有其他的办法。&lt;br&gt;
既然 BCD 没办法直接读 EXT4 分区里面的东西，我们可以曲线救国。BCD 里面提供了一种实模式启动的方式，允许读取一个包含了启动代码的文件。所以一种解决办法就是 &lt;strong&gt;BCD → MBR → VBR → Bootloader&lt;/strong&gt;。由于 GPT 磁盘的第一个扇区被划分成了 Protective MBR，用于兼容 BIOS，所以在 Linux 使用：&lt;br&gt;
&lt;strong&gt;&lt;code&gt;sudo dd if=/dev/sdb of=/mnt/reserved/grub.bin bs=512 count=1&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
可以将第二块硬盘的第一扇区里面的启动代码导出到一个文件，然后使用 BCD 加载这个文件就可以启动 GRUB了。&lt;br&gt;
果真如此？&lt;br&gt;
事实是，这种方法可行，但是并不适用我的情况，因为这是建立在 Windows 和 Linux 安装在同一块硬盘上的情形。&lt;em&gt;grub.bin&lt;/em&gt; 并不能够跨分区寻找 VBR。难道只能作罢？肯定不可能，不然就没有这篇文章了。&lt;br&gt;
查阅了若干文档之后，得知 GRUB 提供了一个 叫做 &lt;em&gt;lnxboot.img&lt;/em&gt; 文件，可以将 GRUB 启动阶段模拟成一个可以启动的 Linux 内核，然后挂载 &lt;em&gt;core.img&lt;/em&gt; 里面必要的模块，从而顺利启动 GRUB。那么将之前的思路修改成 &lt;strong&gt;BCD → VBR → Bootloader&lt;/strong&gt; 就行了，即既然 MBR 不能跨分区以及识别 GPT，那么我们就换成一个可以胜任的不就行了。&lt;/p&gt;
&lt;h1 id=&#34;0x04-制作启动镜像&#34;&gt;0x04 制作启动镜像&lt;/h1&gt;
&lt;p&gt;进入 Arch Linux。虽然在 &lt;em&gt;&lt;strong&gt;/boot/grub/i386-pc/&lt;/strong&gt;&lt;/em&gt; 目录下有一个用于启动的 &lt;em&gt;core.img&lt;/em&gt; 文件，这个文件里面指定的模块路径是相对路径，使用它启动依然会显示错误，需要指定绝对路径以保证万无一失。那么我们就来手动生成一个，顺便集成一些我们需要的模块。&lt;br&gt;
注意，启动镜像稍后会被放在 Windows 的启动分区下面（BCD 的启动分区），所以还需要知道模块所在分区的位置。在 GRUB 中表示磁盘的方式有所不同，如 &lt;em&gt;(hd0,msdos1)&lt;/em&gt; 表示第一块磁盘，使用 MBR 分区表，第一个分区； &lt;em&gt;(hd1,gpt2)&lt;/em&gt;  表示第二块磁盘，使用 GPT分区表，第二个分区。括号不可省，磁盘和分区的起始数字不一样。&lt;/p&gt;
&lt;p&gt;使用  &lt;code&gt;grub-probe&lt;/code&gt; 来获取 &lt;em&gt;&lt;strong&gt;/boot&lt;/strong&gt;&lt;/em&gt; 分区信息。这个例子得到的是 &lt;em&gt;hd1,gpt2&lt;/em&gt;：&lt;br&gt;
&lt;strong&gt;&lt;code&gt;sudo grub-probe --target=bios_hints /boot&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;生成 &lt;em&gt;core.img&lt;/em&gt;：&lt;br&gt;
&lt;strong&gt;&lt;code&gt;sudo grub-mkimage --output=/tmp/core.img --prefix=\(hd1,gpt2\)/grub --format=i386-pc biosdisk part_msdos part_gpt ext2&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
注意像我这样 &lt;em&gt;&lt;strong&gt;/boot&lt;/strong&gt;&lt;/em&gt; 单独分区，prefix 就不需要写成 &lt;em&gt;&lt;strong&gt;\(hd1,gpt2\)/boot/grub&lt;/strong&gt;&lt;/em&gt;，毕竟已经在 &lt;em&gt;&lt;strong&gt;/boot&lt;/strong&gt;&lt;/em&gt; 里面了嘛。默认没有 GPT 支持，所以还需要添加 GPT 模块。&lt;/p&gt;
&lt;p&gt;生成启动镜像：&lt;br&gt;
按照 GRUB 的帮助文档，&lt;em&gt;lnxboot.img&lt;/em&gt; 需要放在 &lt;em&gt;core.img&lt;/em&gt; 之前，由 &lt;em&gt;lnxboot.img&lt;/em&gt; 来加载 &lt;em&gt;core.img&lt;/em&gt;。所幸 BCD 可以一次读取大于一个扇区（512B）的内容，所以将这两个文件合并一下即可：&lt;br&gt;
&lt;strong&gt;&lt;code&gt;sudo cat /usr/lib/grub/i386-pc/lnxboot.img /tmp/core.img &amp;gt; /tmp/grub4bcd.img&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后将 &lt;em&gt;grub4bcd.img&lt;/em&gt; 放到 Windows 启动分区根目录下面就可以了。注意内核默认只能以只读模式挂载 NFTS 文件系统，需要安装扩展包才能读写：&lt;br&gt;
&lt;strong&gt;&lt;code&gt;sudo pacman -S ntfs-3g&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
然后挂载（安装了上述扩展包之后甚至不用指定参数）：&lt;br&gt;
&lt;strong&gt;&lt;code&gt;sudo mount /dev/sda1 /mnt/reserved&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在就可以顺利地将启动镜像复制到 Windows 启动分区下面了。&lt;/p&gt;
&lt;h1 id=&#34;0x05-在-bcd-中添加引导菜单&#34;&gt;0x05 在 BCD 中添加引导菜单&lt;/h1&gt;
&lt;p&gt;重启进入 Windows 10。以管理员权限打开命令行。&lt;/p&gt;
&lt;p&gt;添加入口：&lt;br&gt;
&lt;strong&gt;&lt;code&gt;bcdedit /create /d &amp;quot;Switch to GRUB&amp;quot; /application bootsector&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
会返回一串 UUID，复制下来。之后 UUID 的地方我用 &lt;strong&gt;{ID}&lt;/strong&gt; 表示，用刚才得到的替换即可。&lt;/p&gt;
&lt;p&gt;设置启动分区：&lt;br&gt;
&lt;strong&gt;&lt;code&gt;bcdedit /set {ID} device boot&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设置启动文件：&lt;br&gt;
&lt;strong&gt;&lt;code&gt;Bcdedit /set {ID} path /grub4bcd.img&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将入口添加进启动菜单： &lt;br&gt;
&lt;strong&gt;&lt;code&gt;bcdedit /displayorder {ID} /addlast&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关闭 Metro 启动菜单（不关闭的话切换时会重启，建议关闭）：&lt;br&gt;
&lt;strong&gt;&lt;code&gt;bcdedit /set {default} bootmenupolicy legacy&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后关闭 Windows 10 的 Hybrid 开机功能，否则可能会导致 Windows 丢失数据：&lt;br&gt;
&lt;strong&gt;&lt;code&gt;powercfg /h off&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;0x06-后记&#34;&gt;0x06 后记&lt;/h1&gt;
&lt;p&gt;现在终于可以愉快地切换两个引导菜单了。其实使用 GRUB 来管理两个系统是较为简单的办法。&lt;br&gt;
更为简单的办法是，先装 Windows 然后装 Ubuntu，后者会自动搞定这些麻烦事。╮(╯_╰)╭&lt;/p&gt;
&lt;h1 id=&#34;0x07-参考资料&#34;&gt;0x07 参考资料&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&#34;https://www.gnu.org/software/grub/manual/grub.html#Images&#34;&gt;https://www.gnu.org/software/grub/manual/grub.html#Images&lt;/a&gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;&lt;a href=&#34;http://askubuntu.com/questions/180033/how-to-add-different-drive-ubuntu-to-bcd-manually&#34;&gt;http://askubuntu.com/questions/180033/how-to-add-different-drive-ubuntu-to-bcd-manually&lt;/a&gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Talk:Dual_boot_with_Windows&#34;&gt;https://wiki.archlinux.org/index.php/Talk:Dual_boot_with_Windows&lt;/a&gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Dual_boot_with_Windows&#34;&gt;https://wiki.archlinux.org/index.php/Dual_boot_with_Windows&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
