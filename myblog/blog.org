#+author: Fang Deng
#+startup: show2levels
#+startup: nologdone
#+startup: logdrawer
#+seq_todo: DRAFT(d) | CREATED(c!) PUBLISHED(p!)
#+options: d:t
#+hugo_base_dir: ../
#+hugo_section: blog
#+hugo_auto_set_lastmod: t

* Info Pages
:PROPERTIES:
:EXPORT_HUGO_SECTION: page
:END:
** PUBLISHED About
:PROPERTIES:
:EXPORT_FILE_NAME: about
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :slug about
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :license CC BY-NC-ND 4.0
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :aliases '(contact me)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :toc false
:END:
:LOGBOOK:
- State "PUBLISHED"  from "DRAFT"      [2022-06-05 Mon 01:12]
- State "CREATED"    from              [2022-06-05 Mon 01:12]
:END:
*** Me
Hi there. This is Fang.

I'm currently a C++ developer working with one of the well-known automotive companies.

I have hair. A lot.

Emacser. Former Vimmer.

Oh most importantly, happy wife happy life. :)

*** Contact
Email: fang(at)saffyyre.com

Github: https://github.com/peromage

** PUBLISHED Archives
:PROPERTIES:
:EXPORT_FILE_NAME: archives
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :slug archives
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :layout archives
:END:
:LOGBOOK:
- State "PUBLISHED"  from "DRAFT"      [2022-06-05 Mon 01:12]
- State "CREATED"    from              [2022-06-05 Mon 01:12]
:END:

** PUBLISHED Search
:PROPERTIES:
:EXPORT_FILE_NAME: search
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :slug search
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :layout search
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :outputs '(html json)
:END:
:LOGBOOK:
- State "PUBLISHED"  from "DRAFT"      [2022-06-05 Mon 01:12]
- State "CREATED"    from              [2022-06-05 Mon 01:12]
:END:

* Emacs                                                              :@emacs:
** PUBLISHED Use Org Mode to Manage My Blog        :emacs:org:markdown:hugo:
:PROPERTIES:
:EXPORT_FILE_NAME: use-org-mode-to-manage-my-blog
:END:
:LOGBOOK:
- State "PUBLISHED"  from "DRAFT"      [2022-06-05 Sun 23:54]
- State "CREATED"    from              [2022-06-05 Sun 23:00]
:END:
I've been using Emacs since last year but until recent I started using =org-mode= seriously.  After spending a couple of days reading and watching all kinds of org tutorial as well as using it for documentation, I realized that people who invented this must geniuses.

Org document seems similar with markdown: they are text markup format.  However, Org provides far more capabilities to store metadata and greater editing experience together with Emacs' =org-mode=.

*** Motivation
I used to use markdown to write my blog articles and use /Hugo/ to generate static files.

The workflow is pretty much like:

1. Create a new markdown with header by either snippet template from text editor or Hugo command.
2. Write the article.
3. Set last modified time upon finished.
4. Commit and push then let GitHub CI to generate static files automatically.

It looks typical but later on I found it was really frustrating to manage my articles:

1. I always forgot to update the last modified time.
2. Tags and categories were set in the header each file.  It's difficult check existing tags and categories and make them consistent in the new articles.  For example, I always forgot whether a tag or category was capitalized or dash separated.
3. Painful to browse.

Because of those troubles I gradually lost interests writing articles until I found =org-mode=. So I started planning to manage my articles with it.

*** Choose the Right Way
By checking Hugo's documents, I found that it supports Org backend with [[https://github.com/niklasfasching/go-org][go-org]].  However it seems like just another markdown method but in Org syntax.  Apparently it doesn't use the full Org capabilities.

Later I found [[https://ox-hugo.scripter.co/][ox-hugo]] which is an Org backend in Emacs used for Org file export.  The idea is to write articles in Org syntax with metadata and whatever you like to do in =org-mode= and then export to markdown files through =ox-hugo=.  Finally feed the markdown files to the Hugo engine.  The killer feature is that it supports exporting from subtrees, which means you can manage all my articles in one file categorize them with ease (by the first level outline).  And since all the articles are in the same visible file, they can be refiled and move around with =org-mode= key bindings.  Also all tags are visible and can be applied very easily.  It gives you a lot flexibility to manage the articles in this way.

At the time when this article is read, it's been written in =org-mode= already.  I even use the same file to manage other pages of my blog like about, archives and search pages.  You can checkout my original Org file [[https://github.com/peromage/peromage.github.io/blob/master/myblog/blog.org][here]] to figure out how they are defined.

*** Update CI to Build Static Files on Pushing
Since all the articles are managed by the Org file there is no point to keep the old markdown files.  I need to make GitHub CI export the Org file for me so I don't have to do it locally.

The problem is to setup Emacs on the job runner.  Luckily there are people doing this already by providing a GitHub [[https://github.com/marketplace/actions/set-up-emacs][action]].  Then the rest problem is to export.

I wrote a [[https://github.com/peromage/peromage.github.io/blob/master/org-export.sh][shell script]] and put it to the blog repo root so the job runner can execute it when Emacs is ready.

The idea is simple: install =ox-hugo= from MELPA and use it to export the Org file.  After that, just same with the typical Hugo [[https://github.com/peromage/peromage.github.io/blob/master/.github/workflows/gh-pages.yml][workflow]].

*** A Little Glitch
By doing this workflow all the files are always generated so their last modified date are changed every time.  To solve this, either add a =:LOGBOOK:= or =EXPORT_HUGO_LASTMOD= property to the subtree. Further more simply use /TODO/ and /DONE/ workflow since it generates =:LOGBOOK:= automatically.  =ox-hugo= has a clear [[https://ox-hugo.scripter.co/doc/org-meta-data-to-hugo-front-matter/#front-matter-precedence][explanation]] about how it picks up those date information.  But in my case, I don't really bother it so I stay as it is.

** PUBLISHED Autoloading in Emacs                        :emacs:autoloading:
:PROPERTIES:
:EXPORT_FILE_NAME: autoloading-in-emacs
:END:
:LOGBOOK:
- State "PUBLISHED"  from "DRAFT"      [2022-06-06 Mon 00:22]
- State "CREATED"    from              [2022-06-06 Mon 00:00]
:END:
Autoloading is a neat feature in Emacs.  It speeds up Emacs by lazy load the files.  But it could be a little confusing if you're switching from Vim.

*** Myth - Not Working as Expected
If you have used Vim you know in Vim you can put your library files to the load path variable and Vim autoloads them whenever one of the functions/variables is used.  Initially I thought this is the same in Emacs but with a little effort to put the magic autoload comments before the function/variable definition.  It turned out I was wrong.  When I called my functions Emacs could not find them until I explicitly require them.  This is obviously not my intention.

*** Make It Work
After carefully reading the document, I got that the magic autoload comment is just a [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Autoload.html#index-autoloadp][autoload cookie]] that guides Emacs to generate the real autoload code.  In one word, I have to define the function/variable autoload definition anyways.  But with the cookies it simplifies the process.

1. Add magic comment =;;;###autoload= before the desired function/variable definition.
2. ~M-x~ =update-file-autoloads= command on the library file which contains the definitions that need to be autoloaded.  Store that generated autoload definition file with a different name.
3. Require that autoload definition file in the =init.el=.

That's the process to autoload the custom library.  The downside is the =update-file-autoloads= command has to be called every time the library file is updated.

Alternative way is to use =package-install-from-buffer= to install the library file as a package.  =package.el= does the dirty work for you, takes care of autoload definition generation and loading automatically.

*** Reference
https://emacs.stackexchange.com/questions/8023/how-to-use-autoload

* Coding                                                            :@coding:
** PUBLISHED Initialize std::array at Compile Time    :cpp:meta_programming:
:PROPERTIES:
:EXPORT_FILE_NAME: initialize-std-array-at-compile-time
:END:
:LOGBOOK:
- State "PUBLISHED"  from "PUBLISHED"  [2022-06-04 Sat 18:55]
- State "PUBLISHED"  from "DRAFT"      [2022-03-16 Wed 10:25]
- State "CREATED"    from              [2022-03-16 Wed 10:25]
:END:
*** Background
I've been working on optimization for some C++ code recently. One of the part is to initialize some data at compile time. Consider we have a C style enum definition:

#+begin_src c++
typedef enum Foo {
    AAA = 0,
    BBB,
    CCC
} Foo_t;
#+end_src

We want to have an array of the enum with undefined initial values =999= because by default initialization the values would be =0='s. However, =std::array= can only be initialized by initializer list, which is said:

#+begin_src c++
// Partial initialization
constexpr std::array<Foo_t, 5> array {static_cast<Foo_t>(999), static_cast<Foo_t>(999)};

// Results in int equivalent: {999, 999, 0, 0, 0}
#+end_src

If there are a hundred of elements then you have to write all of them down in the list.

You can, of course, initialize it in a loop but this sacrifices runtime performance.

#+begin_src c++
// Runtime initialization
std::array<Foo_t, 5> array {};
for (auto& i : array) {
    i = static_cast<Foo_t>(999);
}

// Results in int equivalent: {999, 999, 999, 999, 999}
#+end_src

*** Generating code by templates
We can use recursive deduction of templates to generate our code. There is a limit that you can only do 1024 times of recursion but in my case it's enough.

The idea is to count the size to zero and use variadic argument to increase the number of arguments on each recursion. Finally the size of the array will be passed to the bottom and the variadic argument gets expanded.

It's a pretty simple trick.

#+begin_src c++
template<std::size_t N, std::size_t M, typename T, typename... U>
struct ARR_IMPL {
    static constexpr auto arr = ARR_IMPL<N, M-1, T, T, U...>::arr;
};

template<std::size_t N, typename T, typename... U>
struct ARR_IMPL<N, 0, T, U...> {
    static constexpr std::array<T, N> arr {static_cast<U>(999)...};
};

template<std::size_t N, typename T>
struct ARR {
    static constexpr auto arr = ARR_IMPL<N, N-1, T, T>::arr;
};

constexpr auto array1 = ARR<5, Foo_t>::arr;
constexpr auto array2 = ARR<100, Foo_t>::arr;

// array1 results in int equivalent: {999, 999, 999, 999, 999}
// array2 results in int equivalent: {999, 999, 999, 999, 999, ...}
#+end_src

* Tech                                                                :@tech:
** PUBLISHED Windows + Linux 双系统引导手记     :多系统引导:中文:multi_boot:
:PROPERTIES:
:EXPORT_FILE_NAME: Windows-Linux双系统引导手记
:END:
:LOGBOOK:
- State "PUBLISHED"  from "PUBLISHED"  [2022-06-04 Sat 18:55]
- State "PUBLISHED"  from "DRAFT"      [2017-04-05 Wed 19:26]
- State "CREATED"    from              [2017-04-05 Wed 19:26]
:END:
*** 0x00 情况简述
由于开发需要 Linux 环境，所以将老的那台笔记本改造成了双系统。
这台电脑的基本情况是这样的，64GB 固态硬盘 + 720GB 机械硬盘（实际可用空间有折损，这里为了表示方便），Windows 10 已经安装到了固态硬盘上。由于主板较老，只能支持 BIOS。巨硬又说过 Windows 只能支持 BIOS + MBR，所以第一块主位（Master）上的固态硬盘就只能采用 MBR 分区表，分成了两个区，500MB 用作启动分区，剩下的部分全部划给了系统分区。
但是 Linux 表示没有巨硬这种尿性，所以为什么不使用更先进的 GPT 分区表？因此从位（Slave）上的机械硬盘被我分成了这个样子：

| 大小    | 挂载点 | 文件系统       | 备注          |
|---------+--------+----------------+---------------|
| 10 MB   | None   | No File System | BIOS 启动分区 |
| 500 MB  | /boot  | EXT4           | 引导          |
| 100 GB  | /      | EXT4           | 系统          |
| 199.5GB | /home  | EXT4           | 用户          |
| 420 GB  | None   | NTFS           | Windows 数据  |

BIOS 启动分区 1MB 足以，我只是考虑到后续扩展问题。之后在第二块硬盘上安装了 Arch Linux。

*** 0x01 有啥好折腾的？
双系统安装好以后相安无事，BIOS 默认从主位固态硬盘启动。也就是说开机不进行任何操作的话，默认进入的是 Windows 10。只有在开机的时候使用 BIOS 的 Fast Boot 功能，选择从第二块硬盘启动才能进入 Arch Linux。换句话说两个系统彼此都是透明的。
但是作为一个强迫症和完美主义者，万一我想进入 Linux，但是开机的时候错过了，岂不是要重启一次才行？或者万一我又反悔想进入 Windows 又要重启一次？这怎么能忍，所以才有了这次的折腾……

*** 0x02 在 GRUB 中添加引导菜单
对于 GRUB （注：这里所说的 GRUB 指的是 GRUB 2 而不是 GRUB Legacy） 引导的 Linux 来说，切换到 Windows 的 =bootmgr= 是一件很容易的事情，最新版的 GRUB 可以直接启动 =bootmgr= 而不需要之前的 chainloading 模式。
进入 Arch Linux，以 root 权限编辑 =/etc/grub.d/40_custom= ，加入以下菜单：

#+begin_src conf
menuentry "Switch to Microsoft Boot Manager" {
    insmod part_msdos
    insmod ntfs
    insmod search_fs_uuid
    insmod ntldr
    search --fs-uuid --set=root  69B235F6749E84CE
    ntldr /bootmgr
  }
#+end_src

=insmod= 是用于加载必要的模块以便 GRUB 识别并正确启动 Windows。值得注意的是， =search= 一行指定的 UUID 与 Linux 下 =lsblk -f= 看到的 UUID 是不一样的，需要使用

#+begin_src shell
$ sudo grub-probe --target=fs_uuid -d /dev/sda1
#+end_src

来获取 GRUB 下对应的分区 UUID。这个例子中，Windows 启动分区是 =sda1= 。UUID 是唯一的，勿照搬。

当然也可以使用传统的 chainloading 模式：

#+begin_src conf
menuentry "Switch to Microsoft Boot Manager" {
    insmod part_msdos
    insmod ntfs
    insmod search_fs_uuid
    search --fs-uuid --set=root  69B235F6749E84CE
    chainloader +1
  }
#+end_src

保存以后，执行

#+begin_src shell
$ sudo grub-mkconfig -o /boot/grub/grub.cfg
#+end_src

以便更新启动菜单。

不推荐直接编辑 =/boot/grub/grub.cfg= ，因为上述命令会覆盖这个文件，不便于自定义菜单的管理。
这样就可以直接跳转到 =bootmgr= ，让它去启动 Windows。

*** 0x03 BCD 寻思
BCD 是Windows Vista 之后使用的一种启动管理器。有个非常蛋疼的问题就在于，BCD 并不支持 EXT4 分区格式，所以没有办法读到 GRUB。查阅了相关资料，给出的解决办法就是，将 =/boot= 分区格式化成 FAT32 的文件系统。难道我还得再折腾一次文件系统？直觉告诉我一定还有其他的办法。
既然 BCD 没办法直接读 EXT4 分区里面的东西，我们可以曲线救国。BCD 里面提供了一种实模式启动的方式，允许读取一个包含了启动代码的文件。所以一种解决办法就是 =BCD → MBR → VBR → Bootloader= 。由于 GPT 磁盘的第一个扇区被划分成了 Protective MBR，用于兼容 BIOS，所以在 Linux 使用：

#+begin_src shell
$ sudo dd if=/dev/sdb of=/mnt/reserved/grub.bin bs=512 count=1
#+end_src

可以将第二块硬盘的第一扇区里面的启动代码导出到一个文件，然后使用 BCD 加载这个文件就可以启动 GRUB了。
果真如此？
事实是，这种方法可行，但是并不适用我的情况，因为这是建立在 Windows 和 Linux 安装在同一块硬盘上的情形。 =grub.bin= 并不能够跨分区寻找 VBR。难道只能作罢？肯定不可能，不然就没有这篇文章了。
查阅了若干文档之后，得知 GRUB 提供了一个 叫做 =lnxboot.img= 文件，可以将 GRUB 启动阶段模拟成一个可以启动的 Linux 内核，然后挂载 =core.img= 里面必要的模块，从而顺利启动 GRUB。那么将之前的思路修改成 =BCD → VBR → Bootloader= 就行了，即既然 MBR 不能跨分区以及识别 GPT，那么我们就换成一个可以胜任的不就行了。

*** 0x04 制作启动镜像
进入 Arch Linux。虽然在 =/boot/grub/i386-pc/= 目录下有一个用于启动的 =core.img= 文件，这个文件里面指定的模块路径是相对路径，使用它启动依然会显示错误，需要指定绝对路径以保证万无一失。那么我们就来手动生成一个，顺便集成一些我们需要的模块。
注意，启动镜像稍后会被放在 Windows 的启动分区下面（BCD 的启动分区），所以还需要知道模块所在分区的位置。在 GRUB 中表示磁盘的方式有所不同，如 =(hd0,msdos1)= 表示第一块磁盘，使用 MBR 分区表，第一个分区。 =(hd1,gpt2)=  表示第二块磁盘，使用 GPT分区表，第二个分区。括号不可省，磁盘和分区的起始数字不一样。

使用 =grub-probe= 来获取 =/boot= 分区信息。这个例子得到的是 =hd1,gpt2= ：

#+begin_src shell
$ sudo grub-probe --target=bios_hints /boot
#+end_src

生成 =core.img= ：

#+begin_src shell
$ sudo grub-mkimage --output=/tmp/core.img --prefix=\(hd1,gpt2\)/grub --format=i386-pc biosdisk part_msdos part_gpt ext2
#+end_src

注意像我这样 =/boot= 单独分区，prefix 就不需要写成 =\\(hd1,gpt2\\)/boot/grub= ，毕竟已经在 =/boot= 里面了嘛。默认没有 GPT 支持，所以还需要添加 GPT 模块。

生成启动镜像：
按照 GRUB 的帮助文档， =lnxboot.img= 需要放在 =core.img= 之前，由 =lnxboot.img= 来加载 =core.img= 。所幸 BCD 可以一次读取大于一个扇区（512B）的内容，所以将这两个文件合并一下即可：

#+begin_src shell
$ sudo cat /usr/lib/grub/i386-pc/lnxboot.img /tmp/core.img > /tmp/grub4bcd.img
#+end_src

然后将 =grub4bcd.img= 放到 Windows 启动分区根目录下面就可以了。注意内核默认只能以只读模式挂载 NFTS 文件系统，需要安装扩展包才能读写：

#+begin_src shell
$ sudo pacman -S ntfs-3g
#+end_src

然后挂载（安装了上述扩展包之后甚至不用指定参数）：

#+begin_src shell
$ sudo mount /dev/sda1 /mnt/reserved
#+end_src

现在就可以顺利地将启动镜像复制到 Windows 启动分区下面了。

*** 0x05 在 BCD 中添加引导菜单
重启进入 Windows 10。以管理员权限打开命令行。

添加入口：

#+begin_src shell
> bcdedit /create /d "Switch to GRUB" /application bootsector
#+end_src

会返回一串 UUID，复制下来。之后 UUID 的地方我用 ={ID}= 表示，用刚才得到的替换即可。

设置启动分区：

#+begin_src shell
> bcdedit /set {ID} device boot
#+end_src

设置启动文件：

#+begin_src shell
> bcdedit /set {ID} path /grub4bcd.img
#+end_src

将入口添加进启动菜单：

#+begin_src shell
> bcdedit /displayorder {ID} /addlast
#+end_src

关闭 Metro 启动菜单（不关闭的话切换时会重启，建议关闭）：

#+begin_src shell
> bcdedit /set {default} bootmenupolicy legacy
#+end_src

最后关闭 Windows 10 的 Hybrid 开机功能，否则可能会导致 Windows 丢失数据：

#+begin_src shell
> powercfg /h off
#+end_src

*** 0x06 后记
现在终于可以愉快地切换两个引导菜单了。其实使用 GRUB 来管理两个系统是较为简单的办法。
更为简单的办法是，先装 Windows 然后装 Ubuntu，后者会自动搞定这些麻烦事。╮(╯_╰)╭

*** 0x07 参考资料
[[https://www.gnu.org/software/grub/manual/grub.html#Images]]
[[http://askubuntu.com/questions/180033/how-to-add-different-drive-ubuntu-to-bcd-manually]]
[[https://wiki.archlinux.org/index.php/Talk:Dual_boot_with_Windows]]
[[https://wiki.archlinux.org/index.php/Dual_boot_with_Windows]]

** PUBLISHED Git 中的 Subtree 和 Submodule                        :git:中文:
:PROPERTIES:
:EXPORT_FILE_NAME: Git中的Subtree和Submodule
:END:
:LOGBOOK:
- State "PUBLISHED"  from "PUBLISHED"  [2022-06-04 Sat 18:55]
- State "PUBLISHED"  from "DRAFT"      [2017-04-07 Fri 20:53]
- State "CREATED"    from              [2017-04-07 Fri 20:53]
:END:
因为最近弄自己的博客，涉及到了版本库嵌套的问题。记下来也算是给自己一个备忘。

*** 为什么有这样的需求
版本库嵌套很好理解，就是在一个 Git 仓库里面包含了其他的 Git 仓库。通常有这样的需求往往涉及到协同开发。比如这里有一个插件单独的 Git 仓库姑且叫“Plugin”。现在我创建了一个自己的项目，其中需要用到这个“Plugin”插件。通常比较笨的办法就是把插件库源码拖下来，复制到自己的项目里。但是这样当插件库更新的时候，插件源码更新往往比较麻烦。而且如果在使用的过程中修改了插件的源码，也不便于插件单独的版本控制，更别说为插件库贡献代码了。但如果插件单独以 Git 仓库存在于我的项目目录中，以上的问题就解决了。

在 Git 里面提供了两种方式实现上述需求，那就是 Subtree 和 Submodule。

*** Submodule
Submodule 是 Git 里面最早提供的一种方法。顾名思义“子模块”。

**** 添加子模块
执行

#+begin_src shell
$ git submodule add <repo> <module_path>
#+end_src

此时运行 =git status= 可以看到子模块对应的文件夹和一个叫做 =.gitmodules= 文件被添加进了暂存区。其中 =.gitmodules= 是用于记录子模块相关信息的。之后主项目里面的操作照常提交就可以了。

**** 修改子模块
但如果在开发的途中修改了子模块的代码，需要单独到子模块对应的根目录里面进行子模块单独的提交操作。在主项目里面虽然可以看到子模块有变更，但是无法看到具体的更改操作，而是将其看作一个模块整体。一旦子模块产生了新的提交，主项目里面可以看到子模块的 HEAD 变化，从而主项目也应当产生一个新的提交以记录对应关系。
换句话说，主项目就是靠着记录子模块 HEAD 值来判断依赖的。子模块的代码最后将不会进入主项目的版本库里面（只有 HEAD 值）。

现在子模块有了新的提交，为了将服务器上的代码更新，我们只需要进入子模块对应的更目录执行 push 操作就可以了。

**** 更新子模块
此时子模块上游有了新的代码，我们需要将其整合到当前的项目中。有两种方法。

在主项目根目录下运行

#+begin_src shell
$ git submodule foreach git pull
#+end_src

或者切换到子模块的根目录下面

#+begin_src shell
$ git pull
#+end_src

**** 克隆项目
克隆主项目的时候子模块并不会拉取到本地，如果进入对应的目录会发现是空的。
此时应当

#+begin_src shell
$ git submodule init
#+end_src

保持最新

#+begin_src shell
$ git submodule update
#+end_src

或者可以直接一条命令搞定

#+begin_src shell
$ git clone --recursive <repo>
#+end_src

**** 删除子模块
Git 中没有提供直接删除的命令，需要手动完成删除操作。

反向初始化子模块

#+begin_src shell
$ git submodule deinit --force <module_path>
#+end_src

或者直接删掉 =.git/config= 里相关信息

移除子模块

#+begin_src shell
$ git rm <module_path>
#+end_src

如果暂存区还有

#+begin_src shell
$ git rm --cached <module_path>
#+end_src

**** 子模块的坑
***** 提交的坑
假设有 A B 两个人同时在开发一个项目，这个项目里面也包含了一个子模块。此时 A 修改了业务代码，同时修改了一个子模块里面的一个 bug 。A 将这次修改提交，主项目的提交里面指向了子模块新的 HEAD1 ，然后把主项目的版本库 push 到了服务器，但是没有 push 子模块。B 此时 pull 了主项目，然后 update 子模块，被告知找不到子模块的 HEAD1 。因为指向 HEAD1 的提交还在 A 本地机器上。
这就是子模块提交的坑。在多个模块存在的时候操作非常繁琐。

***** 初始化的坑
在执行 =git submodule init= ， =git submodule update= 之后，此时修改子模块可能出现 HEAD 处于游离状态的的提示。如果不注意极有可能出现丢失提交的可能。
解决办法，在以上两条命令之后执行一次检出

#+begin_src shell
$ git checkout <branch>
#+end_src

*** Subtree
**** 添加子项目
首先添加子项目对应的远程服务器

#+begin_src shell
$ git remote add <subrepo_name> <subrepo_remote>
#+end_src

拉取一下

#+begin_src shell
$ git fetch <subrepo_name>
#+end_src

添加子项目到父项目里面

#+begin_src shell
$ git subtree add --squash --prefix=<subrepo_path> <subrepo_name> <branch>
#+end_src

参数 =--squash= 作用在于合并子项目所有提交为一个，并 merge 到父项目的历史中，这样只会出现两个提交记录，避免子项目的提交历史污染父项目。更多讨论可以看[[http://www.fwolf.com/blog/post/246][这里]]。

**** 修改子项目
添加完毕之后照常修改提交各种操作，父项目能够跟踪子项目里面的所有变更。子项目被当做一个正常的子文件夹处理。

如果现在修改了子项目里的一个 bug 并且想要反馈给上游，可以这样操作

#+begin_src shell
$ git subtree push --prefix=<subrepo_path> <subrepo_name> <bug_fixed>
#+end_src

这个操作可以将父项目里所有涉及子项目修改的提交检出。这样在远程仓库里面会出现一个叫做 /bug_fixed/ 的分支。

或者也可以这样操作

#+begin_src shell
$ git subtree split --prefix=<subrepo_path> --branch <new_branch_name>
#+end_src

这个操作跟上面一样将父项目里所有涉及子项目修改的提交检出，并且把子项目的根文件夹设为整个项目的根文件夹，然后检出为父项目的一个新的分支。

然后推送给上游

#+begin_src shell
$ git push <subrepo_remote> <new_branch_name>:<bug_fixed>
#+end_src

之后删除对应本地分支就可以了。

**** 更新子项目
拉取非常方便

#+begin_src shell
$ git subtree pull --prefix=<subrepo_path> <subrepo_name> <branch>
#+end_src

**** 删除子项目
因为子项目在父项目里面就是被当做一个普通的文件夹处理的，所以直接移除文件夹并提交就可以了。

*** Submodule vs. Subtree
Git 官方推荐使用新的 Subtree ，事实证明的确比 Submodule 方便不少。Subtree 不会产生额外的文件，而且子项目的代码包含在父项目里面，不会出现前面提到的坑的问题。具体应用上的对比可以参考[[https://gist.github.com/kvnsmth/4688345][这篇文章]]。Subtree 对于代码迭代较快的项目尤为适合。

但也不是说 Submodule 一无是处， Submodule 在我感觉最大的意义在于可以隔离子项目的业务代码，并且记录严格的依赖关系。对于一些子模块更新较慢的项目还是比较适合的。

*** 参考
[[https://gist.github.com/kvnsmth/4688345][subtree_usage]]
[[http://www.fwolf.com/blog/post/246][subtree_squash]]

** PUBLISHED Dual-booting Windows VHD and Native Linux on a BIOS+GPT PC :multi_boot:
:PROPERTIES:
:EXPORT_FILE_NAME: dual-booting-windows-vhd-and-native-linux-on-a-bios-gpt-pc
:END:
:LOGBOOK:
- State "PUBLISHED"  from "PUBLISHED"  [2022-06-04 Sat 18:55]
- State "PUBLISHED"  from "DRAFT"      [2021-07-09 Fri 16:40]
- State "CREATED"    from              [2021-07-09 Fri 16:40]
:END:
*** Background
Previously I wrote a post for this dual-boot scenario. It is a little outdated. In the past year I mostly worked in the Linux environment on my old laptop, so the Windows seems not to be a necessity which occupies a dedicated partition. However, sometimes it is still needed. That is why I started thinking to improve this setup even further.

Starting from Windows 7, Windows supports boots from a VHD file which makes it so much easier to manage. Also you are able to create differencing disks which are pretty much like snapshots.

For this new configuration, my plan is to use BIOS + GPT disk table + Native Linux + Native Windows booting from VHD + GRUB as the bootloader.

*** Partitioning
To make GPT works with BIOS. It is required to have a small partition [[https://wiki.archlinux.org/title/GRUB][flagged]] with =EF02=.

The partition scheme looks like this:

| Device    |     Start |        End |   Sectors | Size   | Type                 |
|-----------+-----------+------------+-----------+--------+----------------------|
| /dev/sda1 |        34 |       2047 |      2014 | 1007K  | BIOS Boot            |
| /dev/sda2 |      2048 |    1026047 |   1024000 | 500M   | EFI System           |
| /dev/sda3 |   1026048 |  206546943 | 205520896 | 98G    | Linux Filesystem     |
| /dev/sda4 | 206546944 |  835692543 | 629145600 | 300G   | Linux Filesystem     |
| /dev/sda5 | 835692544 | 1465149134 | 629456591 | 300.1G | Microsoft Basic Data |

*** Installing Linux
Any Linux distro would work. I chose Manjaro KDE this time because I found that the Pop OS made my laptop really hot sometimes (Yeah KDE is prettier).

This part should be easy. The GRUB files is going into that EFI partition. For details, check [[https://wiki.archlinux.org/title/GRUB][GRUB wiki]].

*** Preparing to Install Windows
I'm not going to use the standard Windwos installer since I want to install it into a VHD file. To make it work we need a Windows PE environment.

**** Preparing Images
Any Windows PE (Windows 7 and above) would work. The PE ISO image is going to =/boot/wepe.iso=.

Also a Windows ISO image is needed. For example a Windows 7 ISO named =windows7.iso= will be put in the Windows data partition.

**** Adding Windows PE to GRUB
Boot into Linux. Download Windows PE ISO file and move it to the EFI partition (EXT4 partitions might be problematic).

To load this ISO image, =memdisk= tool from =syslinux= is required. Steps as below on Arch based distro:

#+begin_src shell
# Installing syslinux
$ sudo pacman -S syslinux

# Copying memdisk to the boot partition
$ sudo cp /usr/lib/syslinux/bios/memdisk /boot/memdisk

# Adding Windows PE entry to GRUB. 1DB1-9C31 is the boot partition's UUID
$ sudo cat <<EOF >>/etc/grub.d/40_custom
menuentry "WePE x64" {
    search --set=root --no-floppy --fs-uuid 1DB1-9C31
    linux16 /memdisk iso ro
    initrd16 /wepe.iso
}
EOF

# Updating GRUB entries
$ sudo grub-mkconfig -o /boot/grub/grub.cfg
#+end_src

*** Installing Windows to a VHD File
After adding Windows PE to the bootloader entries, it is time to switch the working environment.

Restart the PC, then keep pression =shift= key until the GRUB menu shows up. Now navigate to the Windows PE entry and get in there.

**** Creating a VHD File for Windows
To create a VHD file, open a command line window and enter =diskpart=

#+begin_src shell
# Create a VHD file assuming the NTFS data partition is assigned with D:
DISKPART> create vdisk file=d:\windows7.vhd maximum=64000 type=fixed
DISKPART> select vdisk file=d:\windows7.vhd
DISKPART> attach vdisk

# Disk table type doesn't matter but using MBR for better compatibility
DISKPART> convert mbr

# Create the system partition and assign it with C:
DISKPART> create partition primary
DISKPART> format fs=ntfs quick
DISKPART> assign letter=c
DISKPART> exit
#+end_src

Now the Windows image can be dumped into this VHD file.

**** Extracting Windows Image
Mount the Windows ISO image to =E:= volume and open a command line window

#+begin_src shell
# Get the image index. For example the desired version's index is 1
> dism /get-wiminfo /wimfile=e:\sources\install.wim

# Extract the image. Where E: is the Windows ISO and C: is the VHD file
> dism /apply-image /imagefile:e:\sources\install.wim /index:1 /applydir:c:\
#+end_src

*** Fixing the Windows Bootloader
Stay in Windows PE. Don't restart the PC. We still need to fix the bootloader for Windows.

Normally Windows cannot be booted with a GPT+MBR setup. And also loading the whole Windows VHD file through =memdisk= is not possible because it's too large to load into memory. To fix the boot issue a bridge is needed between Windows and GRUB.

Luckily [[http://reboot.pro/index.php?showtopic=19516&page=2&#entry184489][a small VHD image]] can still be loaded by =memdisk=.

The idea is: GRUB -> MS Bootmgr VHD -> Windows VHD

**** Creating a Dedicated Bootloader Image for Windows
It is same with the process creating a VHD file for Windows system but this time it is a smaller file (32 MB).

#+begin_src shell
# Create a small bootmgr VHD file in the data partition
DISKPART> create vdisk file=d:\bootmgr.vhd maximum=32 type=fixed
DISKPART> select vdisk file=d:\bootmgr.vhd
DISKPART> attach vdisk
DISKPART> convert mbr
DISKPART> create partition primary
DISKPART> format fs=ntfs quick
DISKPART> assign letter=f
DISKPART> exit
#+end_src

Now the =bootmgr= VHD is mounted at =F:=. Then write the boot record and create boot configuration files.

#+begin_src shell
> bootsect /nt60 f: /mbr
> bcdboot c:\Windows /l en-us /s f: /f bios
#+end_src

**** Fixing the BCD Entry
At this point it should be working according to the [[https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/boot-to-vhd--native-boot--add-a-virtual-hard-disk-to-the-boot-menu][Microsoft's document]]. In fact it is not.

Let's check the BCD entries, in a command window:

#+begin_src shell
> bcdedit /store f:\Boot\BCD /enum

Windows Boot Manager
--------------------
identifier              {bootmgr}
device                  partition=F:
description             Windows Boot Manager
locale                  en-us
inherit                 {globalsettings}
default                 {default}
resumeobject            {fcd67427-e033-11eb-8826-cdf90e3873d0}
displayorder            {default}
toolsdisplayorder       {memdiag}
timeout                 30

Windows Boot Loader
-------------------
identifier              {default}
device                  partition=C:
path                    \Windows\system32\winload.exe
description             Windows 7
locale                  en-us
inherit                 {bootloadersettings}
osdevice                partition=C:
systemroot              \Windows
resumeobject            {fcd67427-e033-11eb-8826-cdf90e3873d0}
nx                      OptIn
detecthal               Yes
#+end_src

The =device= and =osdevice= seems to be right but once the Windows VHD is unmounted it becomes =unknown=. According to this [[http://www.mistyprojects.co.uk/documents/BCDEdit/files/device.htm][BCDEdit notes]], BCD entry records the partition's information such as UUID to find the correct partition during bootup. In this case the partition can't be found until the VHD file is mounted. But this VHD file is not mounted automatically.

Thus we need to correct this and let =Bootmgr= locate the VHD file properly.

In a command line window:

#+begin_src shell
# The identifier must match the one which is showing above
> bcdedit /store C:\Boot\BCD /set {default} device vhd=[D:]\windows7.vhd
> bcdedit /store C:\Boot\BCD /set {default} osdevice vhd=[D:]\windows7.vhd
#+end_src

If we check the BCD entry again it doesn't change. But if we unmount the Windows VHD it will become:

#+begin_src shell
> bcdedit /store f:\Boot\BCD /enum

Windows Boot Manager
--------------------
identifier              {bootmgr}
device                  partition=E:
description             Windows Boot Manager
locale                  en-us
inherit                 {globalsettings}
default                 {default}
resumeobject            {fcd67427-e033-11eb-8826-cdf90e3873d0}
displayorder            {default}
toolsdisplayorder       {memdiag}
timeout                 30

Windows Boot Loader
-------------------
identifier              {default}
device                  vhd=[C:]\windows7.vhd
path                    \Windows\system32\winload.exe
description             Windows 7
locale                  en-us
inherit                 {bootloadersettings}
osdevice                vhd=[C:]\windows7.vhd
systemroot              \Windows
resumeobject            {fcd67427-e033-11eb-8826-cdf90e3873d0}
nx                      OptIn
detecthal               Yes
#+end_src

The volume letter doesn't matter, it changes dynamically. Now =bootmgr= is able to locate the VHD file correctly.

*** Adding Windows to GRUB
Restart PC and get into Linux.

Modify the GRUB config file to load =bootmgr=

#+begin_src shell
# Adding Windows (bootmgr) entry to GRUB. 1DB1-9C31 is the boot partition's UUID
$ sudo cat <<EOF >>/etc/grub.d/40_custom
menuentry "Windows 7" {
    search --set=root --no-floppy --fs-uuid 1DB1-9C31
    linux16 /memdisk harddisk
    initrd16 /bootmgr.vhd
}
EOF

# Updating GRUB entries
$ sudo grub-mkconfig -o /boot/grub/grub.cfg
#+end_src

Now we can restart PC. Keep pressing =shift= on bootup to go to the GRUB menu. Select Windows entry to boot Windows.

*** Fixing Windows Initialization Error
During the first time bootup, Windows might have an error showing

#+begin_example
Windows could not complete the installation. To install Windows on this computer, restart the installation.
#+end_example

To [[https://www.howisolve.com/windows-could-not-complete-the-installation-solved/][solve]] this error:

1. Press =SHIFT + F10= to bring up the command prompt.
2. Execute =C:\windows\system32\oobe\msoobe=.
3. Wait for a while and the setup window will show up.
4. Complete the setup and restart.

*** Creating a Differencing Disk
A differencing disk can be used for quick recoveries.

To create it, restart into the Windows PE environment. In a command line window:

#+begin_src shell
# Use the original VHD as base
> move d:\windows7.vhd d:\windows7_base.vhd

# Create a differencing disk based on the original one
# The name of the new differencing disk has to be the name that was recorded in the BCD
> diskpart
DISKPART> creat vdisk file=d:\windows7.vhd parent=d:\windows7_base.vhd
#+end_src

Then all changes made in the future will go into the differencing disk. If system goes wrong one day, simply deleting the the differencing disk and creating a new one would quickly recover from the crysis.

*NOTE: After creating the differencing disk, the base VHD is not supposed to be modified.*

*** References
[[https://wiki.archlinux.org/title/GRUB][GRUB wiki]]
[[https://wzyboy.im/post/1049.html][BIOS + GPT + GRUB + Linux + Windows 折腾笔记]]
[[https://rimo.site/2017/02/08/install-win7-into-vhd/][在 VHD 中安装 Windows 7]]
[[http://reboot.pro/index.php?showtopic=19516&page=2&#entry184489][Hack Bootmgr to boot Windows in BIOS to GPT]]
[[https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/boot-to-vhd--native-boot--add-a-virtual-hard-disk-to-the-boot-menu][Boot to a virtual hard disk: Add a VHDX or VHD to the boot menu]]
[[http://www.mistyprojects.co.uk/documents/BCDEdit/files/device.htm][BCDEdit notes]]
[[https://www.howisolve.com/windows-could-not-complete-the-installation-solved/][100% Solved:Windows could not complete the installation]]

** PUBLISHED Fix Metadata in Google Photo Takeout             :google_photo:
:PROPERTIES:
:EXPORT_FILE_NAME: fix-metadata-in-google-photo-takeout
:END:
:LOGBOOK:
- State "PUBLISHED"  from "PUBLISHED"  [2022-06-04 Sat 18:55]
- State "PUBLISHED"  from "DRAFT"      [2022-03-13 Sun 00:12]
- State "CREATED"    from              [2022-03-13 Sun 00:12]
:END:
Google Photo sucks.

*** Troubles
When exporting photos from Google Photo, a bunch of JSON files come with your photos. Those JSON files contain metadata which is supposed to be stored with your photo files. If you simple import those photo files into another photo manager you will most likely not get a chronological view. Obviously, Google does on purpose so that you will not leave it easily.
However, there is a workaround that is able to merge those metadata into your photos.

*** Restore the Metadate
1. Get =exiftool=: https://github.com/exiftool/exiftool
2. Export your Google Photos and extract the downloaded compressed files into a folder
3. Save the following content to =fix-args.txt=

#+begin_src conf
# Usage: exiftool -@ fix-args.txt <takeout_dir>
-r
-d
%s
-tagsFromFile
%d/%F.json
-ext *
--ext json
-overwrite_original
-progress
-GPSAltitude<GeoDataAltitude
-GPSLatitude<GeoDataLatitude
-GPSLongitude<GeoDataLongitude
-DateTimeOriginal<PhotoTakenTimeTimestamp
-ModifyDate<PhotoLastModifiedTimeTimestamp
-CreateDate<CreationTimeTimestamp
-GPSAltitudeRef<GeoDataAltitude
-GPSLatitudeRef<GeoDataLatitude
-GPSLongitudeRef<GeoDataLongitude
#+end_src

4. Execute

#+begin_src shell
$ exiftool -@ fix-args.txt <takeout_dir>
#+end_src

5. Delete JSON files and import your photos to somewhere else

This argument file contains the fields that are meaningful to me. If you need to merge additional fields you can append them to the last. For details, check the man page of =exiftool=.

** PUBLISHED Minimalist's Multi-boot USB Drive                  :multi_boot:
:PROPERTIES:
:EXPORT_FILE_NAME: minimalists-multi-boot-usb-drive
:END:
:LOGBOOK:
- State "PUBLISHED"  from "PUBLISHED"  [2022-06-04 Sat 18:55]
- State "PUBLISHED"  from "DRAFT"      [2022-01-26 Wed 20:34]
- State "CREATED"    from              [2022-01-26 Wed 20:34]
:END:
*** Story
Recently I've realized a fact that I always have needs to keep a multi-boot USB in my pocket for either Linux or Windows installation. There are a lot tools out there already but I don't really like them. At least, I mean, they are too flashy to me. A beautiful boot menu seems not to be attractive. What I need is just a simple and practical maybe a little ugly boot device. It should be minimalist. More importantly, it has to be easy to setup with the tools on the system already and maintainable. No funky scripts.

*** Old Solution - Clunky
I've been using this solution for a very long time. Setup is pretty straight forward.

The partition scheme used on the USB drive is like (GPT):

| Partition | Size   | Filesystem    | Note                             |
|-----------+--------+---------------+----------------------------------|
| /dev/sda1 | 100 GB | NTFS          | Data partition                   |
| /dev/sda2 | 512 MB | FAT           | EFI partition                    |
| /dev/sda3 | 1 MB   | No filesystem | BIOS boot partition used by GRUB |
| /dev/sda4 | 8 GB   | NTFS          | Windows ISO files                |
| /dev/sda5 | 2 GB   | FAT           | Arch Linux ISO files             |

So the idea is having a big data partition at the front for better access, then installing GRUB files on the second EFI partition with both EFI and BIOS support (Implemented by the third BIOS boot partition. The partition order doesn't matter). Finally, create dedicated partitions to contain the extracted files from installation ISOs.

When the USB drive is plugged in, I can use grub command line to chainload the EFI file that is located in the ISO partition, or the VBR if it's booted with legacy mode.

Well, it's usable but I still feel that it is too much for a small USB drive - too many partitions. If I plug the drive in for just data exchange, there would be a a bunch of partitions mounted and the notification is quite annoying. So I started thinking that there must be a simpler way to do it.

*** New Solution - Much Better
**** Partitioning
The goal is simplicity so the new partition scheme is like this:

| Partition | Size   | Filesystem    | Note                                        |
|-----------+--------+---------------+---------------------------------------------|
| /dev/sda1 | 100 GB | NTFS          | Data partition                              |
| /dev/sda2 | 512 MB | FAT           | EFI partition                               |
| /dev/sda3 | 1 MB   | No filesystem | BIOS boot partition used by GRUB (Optional) |

The third BIOS boot partition is not really necessary since most of computers nowadays are using UEFI. If you really need the legacy compatibility, you can create one. I'll keep it for now.

**** Installing GRUB
Typical GRUB insallation but install for both EFI and BIOS.

#+begin_src shell
$ sudo mount /dev/sda2 /mnt
$ sudo grub-install --target=x86_64-efi --efi-directory=/mnt --boot-directory=/mnt --removable
$ sudo grub-install --target=i386-pc --boot-directory=/mnt /dev/sda
#+end_src

Don't forget to create a GRUB menu config file. Otherwise GRUB will boot into its command line interface (If you know what you're doing). It's a good idea to put a editable config file in the data partition since it will be the most used partition. However, GRUB reads the file in the EFI partition by default: =(esp)/grub/grub.cfg=. We can tell GRUB to read out custom config file after that.


#+begin_src conf
# (esp)/grub/grub.cfg

search --set=root --file /boot.cfg
configfile /boot.cfg
#+end_src

Thus we are done with the EFI partition. All the menu configuration will go into =boot.cfg= in the data partition.

**** Linux Installer
Most of modern Linux distros support booting from a loop device. That is to say, we don't have to extract the content of ISO files. Using GRUB =loopback= command can easily mount a ISO and boot from there. But chainloading the EFI or VBF is not possible. Based on the [[https://www.gnu.org/software/grub/manual/grub/grub.html#Loopback-booting][GRUB manual]]:

#+begin_quote
GRUB is able to read from an image (be it one of CD or HDD) stored on any of its accessible storages (refer to see loopback command). However the OS itself should be able to find its root. This usually involves running a userspace program running before the real root is discovered.
#+end_quote

EFI bootloader usually will fail to find the root device by this method. However, we can manually load the kernel and ramdisk in which we can specify the root device by ourselves.

***** Load Linux ISO
I'm using Arch Linux here for example.

1. Put the ISO file to =(data)/images/archlinux-2022.01.01-x86_64.iso=.
2. Mount ISO. We need to find the kernel loading parameters.
3. In the file =(arch)/syslinux/archiso_sys-linux.cfg= we would see

#+begin_src conf
# Copy to RAM boot option
LABEL arch64ram
TEXT HELP
Boot the Arch Linux install medium on BIOS with Copy-to-RAM option
It allows you to install Arch Linux or perform system maintenance.
ENDTEXT
MENU LABEL Arch Linux install medium (x86_64, BIOS, Copy to RAM)
LINUX /arch/boot/x86_64/vmlinuz-linux
INITRD /arch/boot/intel-ucode.img,/arch/boot/amd-ucode.img,/arch/boot/x86_64/initramfs-linux.img
APPEND archisobasedir=arch archisolabel=ARCH_202201 copytoram
#+end_src

This is a =syslinux= config file. Parameters after =APPEND= are the ones that we're looking for.

Then add the following content to =(data)/boot.cfg=. When copying the =initrd= parameters, don't forget to remove commas.

#+begin_src conf
menuentry "Archiso 202201 RAM" {
    search --set=root --file /boot.cfg
    loopback loop /images/archlinux-2022.01.01-x86_64.iso
    set root=(loop)
    linux /arch/boot/x86_64/vmlinuz-linux archisobasedir=arch archisolabel=ARCH_202201 copytoram
    initrd /arch/boot/intel-ucode.img /arch/boot/amd-ucode.img /arch/boot/x86_64/initramfs-linux.img
}
#+end_src

Then the Linux installer is done. If we need more distros, the process is similar.

**** Windows Installer
I prefer to use NTFS as my data partition's file system because it works on both Linux and Windows, and supports big files. Also I usually just keep one copy of Windows installer so for Windows, I can simply dump the ISO content to the data partition's root. I don't mind the extra a few folders there. Plus some of them can be safely deleted. Then chainloading from GRUB is possible.

In =(data)/boot.cfg=

#+begin_src conf
menuentry "Windows 10 Installer" {
    search --set=root --file /boot.cfg
    chainloader /efi/boot/bootx64.efi
}
#+end_src

**** Windows PE
Alternatively, I can directly boot from a small WinPE image and use =dism= command to extract =install.wim= to the target without accepting the annoying Windows partition scheme (You know what I'm talking about).

To create a PE image we need a Windows environment and a CMD window with admin privilege.

Create a virtual disk to contain PE files. Assigned with volume letter =P:\=.

#+begin_src shell
> diskpart
DISKPART> create vdisk file=c:\winpe.vhd maximum=2000 type=fixed
DISKPART> select vdisk file=c:\winpe.vhd
DISKPART> attach vdisk
DISKPART> convert mbr
DISKPART> create partition primary
DISKPART> format fs=ntfs quick
DISKPART> assign letter=p
DISKPART> exit
#+end_src

Then mount the Windows installer ISO. Assuming the assigned volume is =G:\=.

#+begin_src shell
> dism /apply-image /imagefile:g:\sources\boot.wim /index:1 /applydir:p:\
> dism /image:p:\ /set-targetpath:x:\
> dism /image:p:\ /set-inputlocale:en-us
> dism /image:p:\ /set-userlocale:en-us
#+end_src

Assign EFI partition with volume letter =E:\=.

Before creating the bootloader for Windows PE, we need to backup our GRUB EFI file (Windows PE bootloader will overwrite it). Rename =E:\EFI= to =E:\EFI-grub=.

Create Windows PE bootloader.

#+begin_src shell
> bcdboot p:\Windows /l en-us /s e: /f uefi
#+end_src

Then merge both =E:\EFI= and =E:\EFI-grub=. If it prompts overwriting =E:\EFI\Boot\bootx64.efi=, confirm with yes.

Then add following content to =(data)/boot.cfg=.

#+begin_src conf
menuentry "Windows PE" {
    search --set=root --file /boot.cfg
    chainloader /EFI/Microsoft/Boot/bootmgfw.efi
}
#+end_src

**** Loading Any ISO
Some ISO is capable to be loaded directly into memory. The size of the ISO file is critical. Generally it should not exceed the physical memory. This can be done by =memdisk= from =syslinux=.

Copy the =memdisk= into the EFI partition.

#+begin_src shell
$ sudo cp /usr/lib/syslinux/bios/memdisk (esp)/memdisk
#+end_src

Then put the following content to =(data)/boot.cfg=. For example, loading a Windows PE ISO.

#+begin_src conf
menuentry "Windows PE ISO" {
    search --set=root --file /boot.cfg
    linux16 memdisk iso ro
    initrd16 /images/winpe.iso
}
#+end_src

*** The End
Finally I'm very satisfied with this new USB drive. Yay!

** PUBLISHED Setup A Gaming VM             :gaming:kvm:qemu:gpu_passthrough:
:PROPERTIES:
:EXPORT_FILE_NAME: setup-a-gaming-vm
:END:
:LOGBOOK:
- State "PUBLISHED"  from "PUBLISHED"  [2022-06-04 Sat 18:55]
- State "PUBLISHED"  from "DRAFT"      [2022-03-13 Sun 17:47]
- State "CREATED"    from              [2022-03-13 Sun 17:47]
:END:
*** Before starting
First thing first. I've been rarely using Windows over years except for working and gaming. Linux community grows fast and there are a lot alternatives available. On the contrary, Windows gets crapy every year (Office 365 is still good IMO) so there is no reason to run this huge spyware all the time.

Modern PCs are strong enough to run a VM. Besides most of PCs have both integrated and descret graphic cards. This setup is perfect for gaming VM which requires PCI passthrough.

In this post, I'm not going to explain everything because the ArchWiki is clear enough already. This is just a quick guide for the setup.

NOTE: Avoid Intel K series CPUs which usually don't have integrated graphic card.

*** Get started
**** Identify your PC is qualified
To get high graphic performance, your CPU and motherboard must support =VT-d= and =IOMMU= respectively.

If not, you can stop here and choose the traditional way to dual-boot Linux and Windows.

NOTE: you can check [[https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF][PCI passthrough via OVMF]] prerequisite section for more information.

**** Install QEMU
I wrote a script to handle this automatically so just run [[https://github.com/peromage/rice/blob/master/scripts/install-qemu.sh][this script]] before hands.

NOTE: I'm using Arch Linux.

**** Identify discrete graphic card
In a terminal:

#+begin_src shell
$ lspci -nnk

01:00.0 VGA compatible controller [0300]: NVIDIA Corporation GM204 [GeForce GTX 970] [10de:13c2] (rev a1)
    Subsystem: Gigabyte Technology Co., Ltd Device [1458:367a]
    Kernel driver in use: nouveau
    Kernel modules: nouveau
01:00.1 Audio device [0403]: NVIDIA Corporation GM204 High Definition Audio Controller [10de:0fbb] (rev a1)
    Subsystem: Gigabyte Technology Co., Ltd Device [1458:367a]
    Kernel driver in use: snd_hda_intel
    Kernel modules: snd_hda_intel
#+end_src

Take a note of the device IDs. In this example I have a Nvidia GTX970 graphic card along with a audio controller. They belong to the same group (domain) you have to take them all.

In this case I got =1458:367a= and =1458:367a=. These are the PCI devices that will be passed through to the VM. Other PCI devices can be passed too.

**** Modify kernel parameter
Then we're going to turn IOMMU on and prevent host Linux loading PCI devices that we want to pass-through to the VM.

The kernel parameter passing could be different depending on the bootloader you use. In this example, I use =grub=.

Open =/etc/default/grub= with your favorite text editor. You have to add =intel_iommu=on= to the kernel parameter along with =vfio-pci.ids=10de:13c2,10de:0fbb= which contains the device IDs you got from the previous step.

#+begin_src conf
# /etc/default/grub

# Change this line
GRUB_CMDLINE_LINUX_DEFAULT="loglevel=3 quiet"

# To
GRUB_CMDLINE_LINUX_DEFAULT="loglevel=3 quiet intel_iommu=on vfio-pci.ids=10de:13c2,10de:0fbb"
#+end_src

Then update the bootloader config file.

#+begin_src shell
$ sudo grub-mkconfig -o /boot/grub/grub.cfg
#+end_src

The most tricky part is done. Restart the PC now.

NOTE: You can check =dmesg= after reboot to verify IOMMU is turned on successfully.

#+begin_src shell
$ sudo dmesg | grep -i -e DMAR -e IOMMU

[    0.000000] ACPI: DMAR 0x00000000BDCB1CB0 0000B8 (v01 INTEL  BDW      00000001 INTL 00000001)
[    0.000000] Intel-IOMMU: enabled
[    0.028879] dmar: IOMMU 0: reg_base_addr fed90000 ver 1:0 cap c0000020660462 ecap f0101a
[    0.028883] dmar: IOMMU 1: reg_base_addr fed91000 ver 1:0 cap d2008c20660462 ecap f010da
[    0.028950] IOAPIC id 8 under DRHD base  0xfed91000 IOMMU 1
[    0.536212] DMAR: No ATSR found
[    0.536229] IOMMU 0 0xfed90000: using Queued invalidation
[    0.536230] IOMMU 1 0xfed91000: using Queued invalidation
[    0.536231] IOMMU: Setting RMRR:
[    0.536241] IOMMU: Setting identity map for device 0000:00:02.0 [0xbf000000 - 0xcf1fffff]
[    0.537490] IOMMU: Setting identity map for device 0000:00:14.0 [0xbdea8000 - 0xbdeb6fff]
[    0.537512] IOMMU: Setting identity map for device 0000:00:1a.0 [0xbdea8000 - 0xbdeb6fff]
[    0.537530] IOMMU: Setting identity map for device 0000:00:1d.0 [0xbdea8000 - 0xbdeb6fff]
[    0.537543] IOMMU: Prepare 0-16MiB unity mapping for LPC
[    0.537549] IOMMU: Setting identity map for device 0000:00:1f.0 [0x0 - 0xffffff]
[    2.182790] [drm] DMAR active, disabling use of stolen memory
#+end_src

**** Install the VM
Open virt-manager GUI and follow the guide to setup.

Some settings should be tweaked specifically:

- Overview: Change /Firmware/ to =UEFI=
- CPUs:
  - Change /vCPU allocation/ to the maximal host CPUs. In this case, it's =8=
  - Unselect /Copy host CPU configuration/ and change /Model/ to =host-passthrough=
  - Select /Manually set CPU topology/. Change /Sockets/ to =1=, /Cores/ to =4=, /Threads/ to =2= (Physical core =4= * threads for each core =2=)
- Disk: Change /Disk bus/ to =VirtIO=
- Display Spice: You don't really need it so remove it
- Video: Change to None
- PCI: Add your discrete graphic card as well as anything with it (audio controller etc.)
- USB: Mouse, keyboards, game controllers etc.

After saving the settins, the installation should start but don't install Windows yet. Instead, force power if off. Open VM settings in XML view, add following content to prevent Nvidia driver installer discovering the VM environment.

#+begin_src xml
<features>
  ...
  <hyperv>
    ...
    <vendor_id state='on' value='1234567890ab'/>
    ...
  </hyperv>
  ...
  <kvm>
    <hidden state='on'>
  </kvm>
  ...
</features>
#+end_src

Alternatively, this has the same effect.

NOTE: =win11= is the VM name you've just created.

#+begin_src shell
$ sudo virshpatcher --error43 --vender-id 1234567890ab win11
#+end_src

**** Install virtio drivers
In the Windows VM, download the [[https://github.com/virtio-win/virtio-win-pkg-scripts/blob/master/README.md][virtio driver]] and install it.

NOTE: Check [[https://wiki.archlinux.org/title/QEMU][ArchWiki QEMU]] for more info

*** Post installation
If you don't want to switch monitors you can try [[https://looking-glass.io/][Looking Glass]] which allows you redirect VM display output to a emulated monitor.

*** Reference
[[https://github.com/peromage/rice/blob/master/scripts/install-qemu.sh][[QEMU install script]]
[[https://wiki.archlinux.org/title/QEMU][ArchWiki QEMU]]
[[https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF][ArchWiki OVMF]]
[[https://looking-glass.io/][Looking Glass]]
[[https://github.com/virtio-win/virtio-win-pkg-scripts/blob/master/README.md][Virtio driver]]

** PUBLISHED Shadowsocks Quick Setup                     :shadowsocks:proxy:
:PROPERTIES:
:EXPORT_FILE_NAME: shadowsocks-quick-setup
:END:
:LOGBOOK:
- State "PUBLISHED"  from "PUBLISHED"  [2022-06-04 Sat 18:55]
- State "PUBLISHED"  from "DRAFT"      [2022-03-13 Sun 00:03]
- State "CREATED"    from              [2022-03-13 Sun 00:03]
:END:
This note is written for my personal convenience.

*** Server Setup
**** Installation
Use system package manager to install =shadowsocks-libev=. In this case, for Arch Linux it is =pacman=.

There is also a Python package which can be installed by =pip= but it seems not to be maintained for a long time.

#+begin_src shell
$ sudo pacman -S shadowsocks-libev
#+end_src

**** Shadowsocks Server Configuration
Config file is located at =/etc/shadowsocks/myserver.json=. On FreeBSD it is =/usr/local/etc/shadowsocks/myserver.json=

The file name can vary.

#+begin_src json
{
    "server": "0.0.0.0",
    "server_port": 8388,
    "password": "mypassword",
    "timeout": 300,
    "method": "chacha20-ietf-poly1305",
    "fast_open": false,
    "workers": 1,
    "nameserver": "8.8.8.8"
}
#+end_src

*Note*: For server, ="local_address": "127.0.0.1"= and ="local_port": 1080= would cause problems so don't them.

**** Start the Server as A System Service
The server can be started in the background but it's not persistent after reboot.

#+begin_src shell
$ ss-server -c /etc/shadowsocks/myserver.json &
#+end_src

Use =systemd= to make it run automatically.

*Note*: The config file name has to be placed after =@=.

#+begin_src shell
$ sudo systemctl enable shadowsocks-libev-server@myserver
$ sudo systemctl start shadowsocks-libev-server@myserver
#+end_src

*** Client Helper
**** SS Access Key Generation Script (Bash Script)
This script will prompt you to input parameters that are in the config file to generate a base64 encoded link.

#+begin_src shell
#!/usr/bin/bash
# Usage: this_script.sh
read -p 'Method: ' -r ss_method
read -p 'Password: ' -r ss_password
read -p 'Server IP: ' -r ss_server_ip
read -p 'Server Port: ' -r ss_server_port
echo "ss://" $(printf "${ss_method}:${ss_password}@${ss_server_ip}:${ss_server_port}" | base64)
#+end_src

**** SS Access Key Generation Script (JavaScript)
This approch requires Node.js but it can parse config file automatically.

#+begin_src javascript
// Usage: node this_script.js <config_file>
let argv = process.argv.slice(2);
if (argv.length < 1) {
    console.log("nothing");
    return;
}

const fs = require('fs');

let config_file = argv[0];
let config_json = JSON.parse(fs.readFileSync(config_file));
let ss_url = "ss://" + btoa(`${config_json['method']}:${config_json['password']}@${config_json['server'][0]}:${config_json['server_port']}`);
console.log(ss_url);
#+end_src

** PUBLISHED SSH Over GPG Agent                                    :ssh:gpg:
:PROPERTIES:
:EXPORT_FILE_NAME: ssh-over-gpg-agent
:END:
:LOGBOOK:
- State "PUBLISHED"  from "PUBLISHED"  [2022-06-04 Sat 18:55]
- State "PUBLISHED"  from "DRAFT"      [2022-03-13 Sun 00:02]
- State "CREATED"    from              [2022-03-13 Sun 00:02]
:END:
This is a quick note of =gpg-agent= setup for SSH.

*** Quick Setup
1. Import your GPG authentication key.
2. Enable SSH support for =gpg-agent=.

#+begin_src shell
$ echo enable-ssh-support >> $HOME/.gnupg/gpg-agent.conf
#+end_src

3. Get the authentication keygrip.

#+begin_src shell
$ gpg -k --with-keygrip
#+end_src

4. Add the authentication key to the keychain (replace =KEYGRIP= with the value obtained from the previous step)

#+begin_src shell
$ echo KEYGRIP >> $HOME/.gnupg/sshcontrol
#+end_src

5. Add the following init code to =.bashrc=

#+begin_src shell
unset SSH_AGENT_PID
export SSH_AUTH_SOCK="$(gpgconf --list-dirs agent-ssh-socket)"
export GPG_TTY="$(tty)"
gpg-connect-agent updatestartuptty /bye > /dev/null
#+end_src

6. Kill any running =ssh-agent= and =gpg-agent=, and then open a new Bash session.

*** Misc
**** Export SSH Public Keys

#+begin_src shell
$ gpg --export-ssh-key <uid/fingerprint>
#+end_src

** PUBLISHED Use Git Worktree to Work with Multiple Checkout at the Same Time :git:
:PROPERTIES:
:EXPORT_FILE_NAME: use-git-worktree-to-work-with-multiple-checkout-at-the-same-time
:END:
:LOGBOOK:
- State "PUBLISHED"  from "DRAFT"      [2022-06-06 Mon 00:41]
- State "CREATED"    from              [2022-06-06 Mon 00:30]
:END:
*** Troubles
When working with a complicated project where you have to compare different history versions side by side, it soon becomes frustrating frequently checking out refs.

The old stupid way is to clone multiple repos and checkout to the specific revisions.  When the project is big this might be a trouble because you're basically duplicating files.

*** Savior
Git provides a convenience sub-command =worktree= to checkout a specific ref in another directory without duplicating files.

**** Add a New Checkout

#+begin_src shell
$ git worktree add ../foo-ref-1 <ref>
#+end_src

Of course you can add as many checkouts as you want.

**** Remove a Checkout
When the checkout is no longer needed, it can be deleted from this command.

#+begin_src shell
$ git worktree remove --force ../foo-ref-1
#+end_src

If there are uncommitted changes git will prevent you from deleting the directory.  In this case =--force= flag is needed.

* Grumble                                                          :@grumble:
** PUBLISHED Moving From Vim to Emacs                :vim:emacs:text_editor:
:PROPERTIES:
:EXPORT_FILE_NAME: moving-from-vim-to-emacs
:END:
:LOGBOOK:
- State "PUBLISHED"  from "PUBLISHED"  [2022-06-04 Sat 18:55]
- State "PUBLISHED"  from "DRAFT"      [2021-08-14 Sat 10:29]
- State "CREATED"    from              [2021-08-14 Sat 10:29]
:END:
YouTube has been pushing me a lot Emacs related contents. This is weird since mostly I watch Vim videos only. But probably this is also a great opportunity to try Emacs again.

I have tried Emacs half year ago. I looked a lot Elisp programming fundamentals and tried a few Emacs configurations from others including Doom Emacs. However, it didn't last long since I found that I didn't have enough time to configure this Emacs setup as good as the [[https://github.com/peromage/rice.vim][Vim setup]] that I was using. Also using other's configurations makes things complicated for me. They have too many packages included and I don't know what they are.

After watching a bunch of Emacs videos I decided to pick it up this time, with vanilla Emacs starting from scratch. The reason why I make my mind this time is because I found Emacs can perfectly and elegantly solve some problems that pain my ass:

- More convenient package management.
- High quality packages.
- Easier file management in shell environment within the editor (Dired)
- No third party dependencies like Node.js and Python. The two major plugs that I'm using in Vim are [[https://github.com/neoclide/coc.nvim][Coc]] and [[https://github.com/Yggdroot/LeaderF][Leaderf]]. They require Node.js and Python to work. Since Elisp is power enough, Emacs can handle this easily by itself.
- Server-client architecture. I can even replace Tmux with Emacs now. NeoVim has the similar concept but it cannot match what Emacs has.
- Graphical interface in X mode. This makes Emacs be able to display rich contents.
- Org mode. It looks great to organize to-do list and take notes without switching to other applications.
- Evil mode. No need to worry about missing Vim's features.
- Magit. Looks way better and nicer than fugitive.
- Elisp. Elisp is fun 😉.

The migration is going slowly. Right now my main setup is still Vim + Tmux. There is a little curve learning from vanilla edition of Emacs, but It's not a big deal compared with the first time when I started learning Vim 🙂.

In the end, dont't give me wrong. Vim and Emacs both are great text editor. For me, Vim is more like a spirit, a concept. Once you've learned its high-efficiency key maps, you can use it everywhere. Even though I switch to Emacs I still use Vim mode together with Emacs' powerful extendability. Why not?

