<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>emacs on Fang's Blog</title><link>https://peromage.github.io/tags/emacs/</link><description>Recent content in emacs on Fang's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 06 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://peromage.github.io/tags/emacs/index.xml" rel="self" type="application/rss+xml"/><item><title>Autoloading in Emacs</title><link>https://peromage.github.io/p/autoloading-in-emacs/</link><pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate><guid>https://peromage.github.io/p/autoloading-in-emacs/</guid><description>&lt;p>Autoloading is a neat feature in Emacs. It speeds up Emacs by lazy load the files. But it could be a little confusing if you&amp;rsquo;re switching from Vim.&lt;/p>
&lt;h2 id="myth-not-working-as-expected">Myth - Not Working as Expected&lt;/h2>
&lt;p>If you have used Vim you know in Vim you can put your library files to the load path variable and Vim autoloads them whenever one of the functions/variables is used. Initially I thought this is the same in Emacs but with a little effort to put the magic autoload comments before the function/variable definition. It turned out I was wrong. When I called my functions Emacs could not find them until I explicitly require them. This is obviously not my intention.&lt;/p>
&lt;h2 id="make-it-work">Make It Work&lt;/h2>
&lt;p>After carefully reading the document, I got that the magic autoload comment is just a &lt;a class="link" href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Autoload.html#index-autoloadp" target="_blank" rel="noopener"
>autoload cookie&lt;/a> that guides Emacs to generate the real autoload code. In one word, I have to define the function/variable autoload definition anyways. But with the cookies it simplifies the process.&lt;/p>
&lt;ol>
&lt;li>Add magic comment &lt;code>;;;###autoload&lt;/code> before the desired function/variable definition.&lt;/li>
&lt;li>&lt;code>M-x&lt;/code> &lt;code>update-file-autoloads&lt;/code> command on the library file which contains the definitions that need to be autoloaded. Store that generated autoload definition file with a different name.&lt;/li>
&lt;li>Require that autoload definition file in the &lt;code>init.el&lt;/code>.&lt;/li>
&lt;/ol>
&lt;p>That&amp;rsquo;s the process to autoload the custom library. The downside is the &lt;code>update-file-autoloads&lt;/code> command has to be called every time the library file is updated.&lt;/p>
&lt;p>Alternative way is to use &lt;code>package-install-from-buffer&lt;/code> to install the library file as a package. &lt;code>package.el&lt;/code> does the dirty work for you, takes care of autoload definition generation and loading automatically.&lt;/p>
&lt;h2 id="reference">Reference&lt;/h2>
&lt;p>&lt;a class="link" href="https://emacs.stackexchange.com/questions/8023/how-to-use-autoload" target="_blank" rel="noopener"
>https://emacs.stackexchange.com/questions/8023/how-to-use-autoload&lt;/a>&lt;/p></description></item><item><title>Use Org Mode to Manage My Blog</title><link>https://peromage.github.io/p/use-org-mode-to-manage-my-blog/</link><pubDate>Sun, 05 Jun 2022 23:00:00 +0000</pubDate><guid>https://peromage.github.io/p/use-org-mode-to-manage-my-blog/</guid><description>&lt;p>I&amp;rsquo;ve been using Emacs since last year but until recent I started using &lt;code>org-mode&lt;/code> seriously. After spending a couple of days reading and watching all kinds of org tutorial as well as using it for documentation, I realized that people who invented this must geniuses.&lt;/p>
&lt;p>Org document seems similar with Markdown: they are text markup format. However, Org provides far more capabilities to store metadata and greater editing experience together with Emacs&amp;rsquo; &lt;code>org-mode&lt;/code>.&lt;/p>
&lt;h2 id="motivation">Motivation&lt;/h2>
&lt;p>I used to use Markdown to write my blog articles and use &lt;em>Hugo&lt;/em> to generate static files.&lt;/p>
&lt;p>The workflow is pretty much like:&lt;/p>
&lt;ol>
&lt;li>Create a new Markdown with header by either snippet template from text editor or Hugo command.&lt;/li>
&lt;li>Write the article.&lt;/li>
&lt;li>Set last modified time upon finished.&lt;/li>
&lt;li>Commit and push then let GitHub CI to generate static files automatically.&lt;/li>
&lt;/ol>
&lt;p>It looks typical but later on I found it was really frustrating to manage my articles:&lt;/p>
&lt;ol>
&lt;li>I always forgot to update the last modified time.&lt;/li>
&lt;li>Tags and categories were set in the header each file. It&amp;rsquo;s difficult check existing tags and categories and make them consistent in the new articles. For example, I always forgot whether a tag or category was capitalized or dash separated.&lt;/li>
&lt;li>Painful to browse.&lt;/li>
&lt;/ol>
&lt;p>Because of those troubles I gradually lost interests writing articles until I found &lt;code>org-mode&lt;/code>. So I started planning to manage my articles with it.&lt;/p>
&lt;h2 id="choose-the-right-way">Choose the Right Way&lt;/h2>
&lt;p>By checking Hugo&amp;rsquo;s documents, I found that it supports Org backend with &lt;a class="link" href="https://github.com/niklasfasching/go-org" target="_blank" rel="noopener"
>go-org&lt;/a>. However it seems like just another Markdown method but in Org syntax. Apparently it doesn&amp;rsquo;t use the full Org capabilities.&lt;/p>
&lt;p>Later I found &lt;a class="link" href="https://ox-hugo.scripter.co/" target="_blank" rel="noopener"
>ox-hugo&lt;/a> which is an Org backend in Emacs used for Org file export. The idea is to write articles in Org syntax with metadata and whatever you like to do in &lt;code>org-mode&lt;/code> and then export to Markdown files through &lt;code>ox-hugo&lt;/code>. Finally feed the Markdown files to the Hugo engine. The killer feature is that it supports exporting from subtrees, which means you can manage all my articles in one file categorize them with ease (by the first level outline). And since all the articles are in the same visible file, they can be refiled and move around with &lt;code>org-mode&lt;/code> key bindings. Also all tags are visible and can be applied very easily. It gives you a lot flexibility to manage the articles in this way.&lt;/p>
&lt;p>At the time when this article is read, it&amp;rsquo;s been written in &lt;code>org-mode&lt;/code> already. I even use the same file to manage other pages of my blog like about, archives and search pages. You can checkout my original Org file &lt;a class="link" href="https://github.com/peromage/peromage.github.io/blob/master/myblog/blog.org" target="_blank" rel="noopener"
>here&lt;/a> to figure out how they are defined.&lt;/p>
&lt;h2 id="update-ci-to-build-static-files-on-pushing">Update CI to Build Static Files on Pushing&lt;/h2>
&lt;p>Since all the articles are managed by the Org file there is no point to keep the old Markdown files. I need to make GitHub CI export the Org file for me so I don&amp;rsquo;t have to do it locally.&lt;/p>
&lt;p>The problem is to setup Emacs on the job runner. Luckily there are people doing this already by providing a GitHub &lt;a class="link" href="https://github.com/marketplace/actions/set-up-emacs" target="_blank" rel="noopener"
>action&lt;/a>. Thanks Steve Purcell and the people who worked on this!&lt;/p>
&lt;p>Now with the Emacs setup ready, one problem left is to export from Org files to Markdown. The idea is pretty straight forward: install &lt;code>ox-hugo&lt;/code> from MELPA and export through it. A simple shell command should do the job.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">emacs -nw --batch --eval &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="s1">&amp;#39;(progn
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> (package-initialize)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> (add-to-list (quote package-archives) (quote (&amp;#34;melpa&amp;#34; . &amp;#34;https://melpa.org/packages/&amp;#34;)))
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> (package-refresh-contents)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> (package-install (quote ox-hugo))
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> (find-file &amp;#34;myblog/blog.org&amp;#34;)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> (org-hugo-export-wim-to-md :all))&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>After that, feed the generated Markdown files to Hugo engine. No difference from the typical Hugo &lt;a class="link" href="https://gohugo.io/hosting-and-deployment/hosting-on-github/" target="_blank" rel="noopener"
>workflow&lt;/a>.&lt;/p>
&lt;p>See here for my &lt;a class="link" href="https://github.com/peromage/peromage.github.io/blob/master/org-export.sh" target="_blank" rel="noopener"
>job runner script&lt;/a> and &lt;a class="link" href="https://github.com/peromage/peromage.github.io/blob/master/.github/workflows/gh-pages.yml" target="_blank" rel="noopener"
>workflow configuration&lt;/a>.&lt;/p>
&lt;h2 id="fix-the-last-modified-date">Fix the Last Modified Date&lt;/h2>
&lt;p>By doing this workflow all the files are always generated so their last modified date are constantly changed (with &lt;code>#+hugo_auto_set_lastmod: t&lt;/code> in the header). &lt;code>ox-hugo&lt;/code> seems not to have a proper solution to calculate the diff between changes (could be hard though). The best way to solve this is to add either a &lt;code>:LOGBOOK:&lt;/code> or a &lt;code>EXPORT_HUGO_LASTMOD&lt;/code> property to the subtree. Or even simpler to use &lt;em>TODO&lt;/em> and &lt;em>DONE&lt;/em> workflow since it generates &lt;code>:LOGBOOK:&lt;/code> automatically. When any one of them specified &lt;code>ox-hugo&lt;/code> will the value from it &lt;a class="link" href="https://ox-hugo.scripter.co/doc/dates/#last-modified" target="_blank" rel="noopener"
>instead of generating a new date&lt;/a>.&lt;/p>
&lt;p>Since manually changing the modification time in &lt;code>EXPORT_HUGO_LASTMOD&lt;/code> sucks and it&amp;rsquo;s the same solution back in the Markdown style, this time I decided to use &amp;ldquo;Org&amp;rdquo; way to fix this problem. By looking at the document, &lt;code>:LOGBOOK:&lt;/code> has &lt;a class="link" href="https://ox-hugo.scripter.co/doc/org-meta-data-to-hugo-front-matter/#front-matter-precedence" target="_blank" rel="noopener"
>the highest priority&lt;/a> among other options and also has a synergy with todo workflow. That&amp;rsquo;s cool. I can treat my article writing like any other tasks.&lt;/p>
&lt;p>But I don&amp;rsquo;t quite like the default keywords &lt;em>TODO&lt;/em> and &lt;em>DONE&lt;/em> since they doesn&amp;rsquo;t sound semantic to the articles. So I added a header to my blog Org file: &lt;code>#+seq_todo: DRAFT(d) | PUBLISHED(p!)&lt;/code>.&lt;/p>
&lt;p>Then I found another problem that whenever I change the state from &lt;em>DRAFT&lt;/em> to &lt;em>PUBLISHED&lt;/em> there is always a &lt;code>CLOSED&lt;/code> time property added to the article. This is because I have &lt;code>(setq org-log-done 'time)&lt;/code> in my Emacs configuration file. It duplicates &lt;code>:LOGBOOK:&lt;/code> since it has already logged the transition time and I don&amp;rsquo;t want to change my Emacs configuration specific for this file. So I added another header to my blog Org file: &lt;code>#+startup: nologdone&lt;/code> and also make sure the state transition records are always put into the drawer: &lt;code>#+startup: logdrawer&lt;/code>.&lt;/p>
&lt;p>Okay now I should be able to start a new article with &lt;em>DRAFT&lt;/em> prefix and then use &lt;code>C-c C-t&lt;/code> to change it to &lt;em>PUBLISHED&lt;/em> whenever I&amp;rsquo;m done writing. However things are still not going as I expected. Remember the &lt;a class="link" href="https://ox-hugo.scripter.co/doc/org-meta-data-to-hugo-front-matter/#front-matter-precedence" target="_blank" rel="noopener"
>date precedence&lt;/a> page? The first transition to &lt;em>PUBLISHED&lt;/em> state record is recognized as the creation date. Only the second or later records to &lt;em>PUBLISHED&lt;/em> state will be read as the last modified date. That&amp;rsquo;s dumb. To fix this, I added a new todo item and now it&amp;rsquo;s like: &lt;code>#+seq_todo: DRAFT(d) | CREATED(c!) PUBLISHED(p!)&lt;/code>.&lt;/p>
&lt;p>Now my blog header is like:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">#+author: Fang Deng
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#+startup: show2levels
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#+startup: nologdone
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#+startup: logdrawer
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#+seq_todo: DRAFT(d) | CREATED(c!) PUBLISHED(p!)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#+options: d:t
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#+hugo_base_dir: ../
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#+hugo_section: blog
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#+hugo_auto_set_lastmod: t
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Don&amp;rsquo;t forget the &lt;code>#+options: d:t&lt;/code>. &lt;code>ox-hugo&lt;/code> will not export &lt;code>:LOGBOOK:&lt;/code> without it.&lt;/p>
&lt;p>Finally a sweet snippet file to save my life.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"># -*- mode: snippet -*-
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># name: Hugo new article
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># key: hugonew
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># --
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">** DRAFT ${1:TITLE}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">:PROPERTIES:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">:EXPORT_FILE_NAME: ${1:$(replace-regexp-in-string &amp;#34;[^A-Za-z0-9._-]&amp;#34; &amp;#34;&amp;#34; (replace-regexp-in-string &amp;#34; &amp;#34; &amp;#34;-&amp;#34; (downcase yas-text)))}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">:END:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">:LOGBOOK:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- State &amp;#34;CREATED&amp;#34; from [`(string-trim (format-time-string (cdr org-time-stamp-formats)) &amp;#34;&amp;lt;&amp;#34; &amp;#34;&amp;gt;&amp;#34;)`]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">:END:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Now a new article will come with its creation time. Whenever the article is done, &lt;code>C-c C-t&lt;/code> to mark it &lt;em>PUBLISHED&lt;/em> which will be the last modified time. If the article is modified in the future, simply &lt;code>C-c C-t&lt;/code> again to add another &lt;em>PUBLISHED&lt;/em> state and the last modified time will be refreshed on export. Now I have a neat log book to record my changes. No more manually editing suckers!&lt;/p></description></item><item><title>Moving From Vim to Emacs</title><link>https://peromage.github.io/p/moving-from-vim-to-emacs/</link><pubDate>Sat, 14 Aug 2021 10:29:00 +0000</pubDate><guid>https://peromage.github.io/p/moving-from-vim-to-emacs/</guid><description>&lt;p>YouTube has been pushing me a lot Emacs related contents. This is weird since mostly I watch Vim videos only. But probably this is also a great opportunity to try Emacs again.&lt;/p>
&lt;p>I have tried Emacs half year ago. I looked a lot Elisp programming fundamentals and tried a few Emacs configurations from others including Doom Emacs. However, it didn&amp;rsquo;t last long since I found that I didn&amp;rsquo;t have enough time to configure this Emacs setup as good as the &lt;a class="link" href="https://github.com/peromage/rice.vim" target="_blank" rel="noopener"
>Vim setup&lt;/a> that I was using. Also using other&amp;rsquo;s configurations makes things complicated for me. They have too many packages included and I don&amp;rsquo;t know what they are.&lt;/p>
&lt;p>After watching a bunch of Emacs videos I decided to pick it up this time, with vanilla Emacs starting from scratch. The reason why I make my mind this time is because I found Emacs can perfectly and elegantly solve some problems that pain my ass:&lt;/p>
&lt;ul>
&lt;li>More convenient package management.&lt;/li>
&lt;li>High quality packages.&lt;/li>
&lt;li>Easier file management in shell environment within the editor (Dired)&lt;/li>
&lt;li>No third party dependencies like Node.js and Python. The two major plugs that I&amp;rsquo;m using in Vim are &lt;a class="link" href="https://github.com/neoclide/coc.nvim" target="_blank" rel="noopener"
>Coc&lt;/a> and &lt;a class="link" href="https://github.com/Yggdroot/LeaderF" target="_blank" rel="noopener"
>Leaderf&lt;/a>. They require Node.js and Python to work. Since Elisp is power enough, Emacs can handle this easily by itself.&lt;/li>
&lt;li>Server-client architecture. I can even replace Tmux with Emacs now. NeoVim has the similar concept but it cannot match what Emacs has.&lt;/li>
&lt;li>Graphical interface in X mode. This makes Emacs be able to display rich contents.&lt;/li>
&lt;li>Org mode. It looks great to organize todo list and take notes without switching to other applications.&lt;/li>
&lt;li>Evil mode. No need to worry about missing Vim&amp;rsquo;s features.&lt;/li>
&lt;li>Magit. Looks way better and nicer than fugitive.&lt;/li>
&lt;li>Elisp. Elisp is fun 😉.&lt;/li>
&lt;/ul>
&lt;p>The migration is going slowly. Right now my main setup is still Vim + Tmux. There is a little curve learning from vanilla edition of Emacs, but It&amp;rsquo;s not a big deal compared with the first time when I started learning Vim 🙂.&lt;/p>
&lt;p>In the end, dont&amp;rsquo;t give me wrong. Vim and Emacs both are great text editor. For me, Vim is more like a spirit, a concept. Once you&amp;rsquo;ve learned its high-efficiency key maps, you can use it everywhere. Even though I switch to Emacs I still use Vim mode together with Emacs&amp;rsquo; powerful extendability. Why not?&lt;/p></description></item></channel></rss>